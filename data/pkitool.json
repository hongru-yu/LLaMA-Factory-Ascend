[
    {
        "instruction": "请使用PKITool的软实现生成基于RSA算法，密钥长度为1024的外部非对称密钥对",
        "input": "",
        "output": "public void generateRSA1024Key() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(\"RSA\");\n        Map<String, Object> mapattr = new HashMap<String, Object>();\n        mapattr.put(\"isExport\", true);\n        mechanism.setParam(mapattr);\n        // 生成密钥对，JKeyPair为非对称密钥对\n        JKeyPair keypair = softSession.generateKeyPair(mechanism, 1024);\n        String publicKey = java.util.Base64.getEncoder().encodeToString(keypair.getPublicKey().getKey());\n        String privateKey = java.util.Base64.getEncoder().encodeToString(keypair.getPrivateKey().getKey());\n        System.out.println(\"public key: \" + publicKey);\n        System.out.println(\"private key: \" + privateKey);\n    } catch (PKIException e) {\n        e.printStackTrace();\n    } finally {\n        try {\n            crypto.finalize(JCrypto.JSOFT_LIB, null);\n        } catch (PKIException e) {\n            e.printStackTrace();\n        }\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现生成基于RSA算法，密钥长度为2048的外部非对称密钥对",
        "input": "",
        "output": "public void generateRSA2048Key() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(\"RSA\");\n        Map<String, Object> mapattr = new HashMap<String, Object>();\n        mapattr.put(\"isExport\", true);\n        mechanism.setParam(mapattr);\n        // 生成密钥对，JKeyPair为非对称密钥对\n        JKeyPair keypair = softSession.generateKeyPair(mechanism, 2048);\n        String publicKey = java.util.Base64.getEncoder().encodeToString(keypair.getPublicKey().getKey());\n        String privateKey = java.util.Base64.getEncoder().encodeToString(keypair.getPrivateKey().getKey());\n        System.out.println(\"public key: \" + publicKey);\n        System.out.println(\"private key: \" + privateKey);\n    } catch (PKIException e) {\n        e.printStackTrace();\n    } finally {\n        try {\n            crypto.finalize(JCrypto.JSOFT_LIB, null);\n        } catch (PKIException e) {\n            e.printStackTrace();\n        }\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现生成基于RSA算法，密钥长度为3072的外部非对称密钥对",
        "input": "",
        "output": "public void generateRSA3072Key() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(\"RSA\");\n        Map<String, Object> mapattr = new HashMap<String, Object>();\n        mapattr.put(\"isExport\", true);\n        mechanism.setParam(mapattr);\n        // 生成密钥对，JKeyPair为非对称密钥对\n        JKeyPair keypair = softSession.generateKeyPair(mechanism, 3072);\n        String publicKey = java.util.Base64.getEncoder().encodeToString(keypair.getPublicKey().getKey());\n        String privateKey = java.util.Base64.getEncoder().encodeToString(keypair.getPrivateKey().getKey());\n        System.out.println(\"public key: \" + publicKey);\n        System.out.println(\"private key: \" + privateKey);\n    } catch (PKIException e) {\n        e.printStackTrace();\n    } finally {\n        try {\n            crypto.finalize(JCrypto.JSOFT_LIB, null);\n        } catch (PKIException e) {\n            e.printStackTrace();\n        }\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现生成基于RSA算法，密钥长度为4096的外部非对称密钥对",
        "input": "",
        "output": "public void generateRSA4096Key() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(\"RSA\");\n        Map<String, Object> mapattr = new HashMap<String, Object>();\n        mapattr.put(\"isExport\", true);\n        mechanism.setParam(mapattr);\n        // 生成密钥对，JKeyPair为非对称密钥对\n        JKeyPair keypair = softSession.generateKeyPair(mechanism, 4096);\n        String publicKey = java.util.Base64.getEncoder().encodeToString(keypair.getPublicKey().getKey());\n        String privateKey = java.util.Base64.getEncoder().encodeToString(keypair.getPrivateKey().getKey());\n        System.out.println(\"public key: \" + publicKey);\n        System.out.println(\"private key: \" + privateKey);\n    } catch (PKIException e) {\n        e.printStackTrace();\n    } finally {\n        try {\n            crypto.finalize(JCrypto.JSOFT_LIB, null);\n        } catch (PKIException e) {\n            e.printStackTrace();\n        }\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现生成基于SM2算法的外部非对称密钥对",
        "input": "",
        "output": "public void generateSM2Key() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(\"SM2\");\n        Map<String, Object> mapattr = new HashMap<String, Object>();\n        mapattr.put(\"isExport\", true);\n        mechanism.setParam(mapattr);\n        // 生成密钥对，JKeyPair为非对称密钥对\n        JKeyPair keypair = softSession.generateKeyPair(mechanism, 256);\n        String publicKey = java.util.Base64.getEncoder().encodeToString(keypair.getPublicKey().getKey());\n        String privateKey = java.util.Base64.getEncoder().encodeToString(keypair.getPrivateKey().getKey());\n        System.out.println(\"public key: \" + publicKey);\n        System.out.println(\"private key: \" + privateKey);\n    } catch (PKIException e) {\n        e.printStackTrace();\n    } finally {\n        try {\n            crypto.finalize(JCrypto.JSOFT_LIB, null);\n        } catch (PKIException e) {\n            e.printStackTrace();\n        }\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现生成基于ECC算法、曲线类型为secp256r1的外部非对称密钥对",
        "input": "",
        "output": "public void generateECCKey() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(\"secp256r1\");\n        Map<String, Object> mapattr = new HashMap<String, Object>();\n        mapattr.put(\"isExport\", true);\n        mechanism.setParam(mapattr);\n        // 生成密钥对，JKeyPair为非对称密钥对\n        JKeyPair keypair = softSession.generateKeyPair(mechanism, 256);\n        String publicKey = java.util.Base64.getEncoder().encodeToString(keypair.getPublicKey().getKey());\n        String privateKey = java.util.Base64.getEncoder().encodeToString(keypair.getPrivateKey().getKey());\n        System.out.println(\"public key: \" + publicKey);\n        System.out.println(\"private key: \" + privateKey);\n    } catch (PKIException e) {\n        e.printStackTrace();\n    } finally {\n        try {\n            crypto.finalize(JCrypto.JSOFT_LIB, null);\n        } catch (PKIException e) {\n            e.printStackTrace();\n        }\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于AES-ECB算法，密钥长度为128，支持补位的加解密运算代码",
        "input": "",
        "output": "public void encryptAES_128_ECB() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism, 128);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.AES_ECB), jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.AES_ECB), jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于AES-ECB算法，密钥长度为128，不补位的加解密运算代码",
        "input": "",
        "output": "public void encryptAES_128_ECB_NoPadding() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"1234567812345678\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism, 128);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.AES_ECB_NOPADDING), jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.AES_ECB_NOPADDING), jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于AES-ECB算法，密钥长度为192，支持补位的加解密运算代码",
        "input": "",
        "output": "public void encryptAES_192_ECB() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism, 192);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.AES_ECB), jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.AES_ECB), jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于AES-ECB算法，密钥长度为192，不补位的加解密运算代码",
        "input": "",
        "output": "public void encryptAES_192_ECB_NoPadding() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"1234567812345678\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism, 192);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.AES_ECB_NOPADDING), jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.AES_ECB_NOPADDING), jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于AES-ECB算法，密钥长度为256，支持补位的加解密运算代码",
        "input": "",
        "output": "public void encryptAES_256_ECB() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism, 256);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.AES_ECB), jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.AES_ECB), jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于AES-ECB算法，密钥长度为256，不补位的加解密运算代码",
        "input": "",
        "output": "public void encryptAES_256_ECB_NoPadding() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"1234567812345678\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism, 256);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.AES_ECB_NOPADDING), jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.AES_ECB_NOPADDING), jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于AES-CBC算法，密钥长度为128，支持补位的加解密运算代码",
        "input": "",
        "output": "public void encryptAES_128_CBC() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 128);\n        // 定义随机向量，也可以自定义\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 16);\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(iv);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.AES_CBC);\n        mechanism.setParam(cbcParam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于AES-CBC算法，密钥长度为128，不补位的加解密运算代码",
        "input": "",
        "output": "public void encryptAES_128_CBC_NoPadding() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"1234567812345678\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 128);\n        // 定义随机向量，也可以自定义\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 16);\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(iv);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.AES_CBC_NOPADDING);\n        mechanism.setParam(cbcParam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于AES-CBC算法，密钥长度为192，支持补位的加解密运算代码",
        "input": "",
        "output": "public void encryptAES_192_CBC() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 192);\n        // 定义随机向量，也可以自定义\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 16);\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(iv);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.AES_CBC);\n        mechanism.setParam(cbcParam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于AES-CBC算法，密钥长度为192，不补位的加解密运算代码",
        "input": "",
        "output": "public void encryptAES_192_CBC_NoPadding() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"1234567812345678\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 192);\n        // 定义随机向量，也可以自定义\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 16);\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(iv);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.AES_CBC_NOPADDING);\n        mechanism.setParam(cbcParam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于AES-CBC算法，密钥长度为256，支持补位的加解密运算代码",
        "input": "",
        "output": "public void encryptAES_256_CBC() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 256);\n        // 定义随机向量，也可以自定义\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 16);\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(iv);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.AES_CBC);\n        mechanism.setParam(cbcParam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于AES-CBC算法，密钥长度为256，不补位的加解密运算代码",
        "input": "",
        "output": "public void encryptAES_256_CBC_NoPadding() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"1234567812345678\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 256);\n        // 定义随机向量，也可以自定义\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 16);\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(iv);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.AES_CBC_NOPADDING);\n        mechanism.setParam(cbcParam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于AES-GCM算法，密钥长度为128的加解密运算代码",
        "input": "",
        "output": "public void encryptAES_128_GCM() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 128);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.AES_GCM_NOPADDING);\n        // 定义向量\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 16);\n        // 设置加密机制参数\n        CCMParam ccmparam = new CCMParam();\n        ccmparam.setNonce(iv);\n        mechanism.setParam(ccmparam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于AES-GCM算法，密钥长度为192的加解密运算代码",
        "input": "",
        "output": "public void encryptAES_192_GCM() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 192);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.AES_GCM_NOPADDING);\n        // 定义向量\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 16);\n        // 设置加密机制参数\n        CCMParam ccmparam = new CCMParam();\n        ccmparam.setNonce(iv);\n        mechanism.setParam(ccmparam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于AES-GCM算法，密钥长度为256的加解密运算代码",
        "input": "",
        "output": "public void encryptAES_256_GCM() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 256);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.AES_GCM_NOPADDING);\n        // 定义向量\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 16);\n        // 设置加密机制参数\n        CCMParam ccmparam = new CCMParam();\n        ccmparam.setNonce(iv);\n        mechanism.setParam(ccmparam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于AES-CFB算法，密钥长度为128，支持补位的加解密运算代码",
        "input": "",
        "output": "public void encryptAES_128_CFB() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 128);\n        // 定义随机向量，也可以自定义\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 16);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.AES_CFB);\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(iv);\n        mechanism.setParam(cbcParam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于AES-CFB算法，密钥长度为128，不补位的加解密运算代码",
        "input": "",
        "output": "public void encryptAES_128_CFB_NoPadding() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 128);\n        // 定义随机向量，也可以自定义\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 16);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.AES_CFB_NOPADDING);\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(iv);\n        mechanism.setParam(cbcParam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于AES-CFB算法，密钥长度为192，支持补位的加解密运算代码",
        "input": "",
        "output": "public void encryptAES_192_CFB() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 192);\n        // 定义随机向量，也可以自定义\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 16);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.AES_CFB);\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(iv);\n        mechanism.setParam(cbcParam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于AES-CFB算法，密钥长度为192，不补位的加解密运算代码",
        "input": "",
        "output": "public void encryptAES_192_CFB_NoPadding() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 192);\n        // 定义随机向量，也可以自定义\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 16);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.AES_CFB_NOPADDING);\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(iv);\n        mechanism.setParam(cbcParam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于AES-CFB算法，密钥长度为256，支持补位的加解密运算代码",
        "input": "",
        "output": "public void encryptAES_256_CFB() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 256);\n        // 定义随机向量，也可以自定义\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 16);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.AES_CFB);\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(iv);\n        mechanism.setParam(cbcParam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于AES-CFB算法，密钥长度为128，不补位的加解密运算代码",
        "input": "",
        "output": "public void encryptAES_256_CFB_NoPadding() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 256);\n        // 定义随机向量，也可以自定义\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 16);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.AES_CFB_NOPADDING);\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(iv);\n        mechanism.setParam(cbcParam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于AES-XTS算法，密钥长度为256，支持补位的加解密运算代码",
        "input": "",
        "output": "public void encryptAES_256_XTS() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"1234567812345678\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 256);\n        // 定义随机向量，也可以自定义\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 16);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.AES_XTS);\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(iv);\n        mechanism.setParam(cbcParam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于AES-XTS算法，密钥长度为256，不补位的加解密运算代码",
        "input": "",
        "output": "public void encryptAES_256_XTS_NoPadding() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"1234567812345678\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 256);\n        // 定义随机向量，也可以自定义\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 16);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.AES_XTS_NOPADDING);\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(iv);\n        mechanism.setParam(cbcParam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于AES-CTR算法，密钥长度为128，支持补位的加解密运算代码",
        "input": "",
        "output": "public void encryptAES_128_CTR() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"1234567812345678\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 128);\n        // 定义随机向量，也可以自定义\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 16);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.AES_CTR);\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(iv);\n        mechanism.setParam(cbcParam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于AES-CTR算法，密钥长度为128，不补位的加解密运算代码",
        "input": "",
        "output": "public void encryptAES_128_CTR_NoPadding() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"1234567812345678\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 128);\n        // 定义随机向量，也可以自定义\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 16);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.AES_CTR_NOPADDING);\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(iv);\n        mechanism.setParam(cbcParam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于AES-CTR算法，密钥长度为192，支持补位的加解密运算代码",
        "input": "",
        "output": "public void encryptAES_192_CTR() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"1234567812345678\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 192);\n        // 定义随机向量，也可以自定义\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 16);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.AES_CTR);\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(iv);\n        mechanism.setParam(cbcParam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于AES-CTR算法，密钥长度为192，不补位的加解密运算代码",
        "input": "",
        "output": "public void encryptAES_192_CTR_NoPadding() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"1234567812345678\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 192);\n        // 定义随机向量，也可以自定义\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 16);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.AES_CTR_NOPADDING);\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(iv);\n        mechanism.setParam(cbcParam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于AES-CTR算法，密钥长度为256，支持补位的加解密运算代码",
        "input": "",
        "output": "public void encryptAES_256_CTR() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"1234567812345678\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 256);\n        // 定义随机向量，也可以自定义\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 16);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.AES_CTR);\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(iv);\n        mechanism.setParam(cbcParam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于AES-CTR算法，密钥长度为256，不补位的加解密运算代码",
        "input": "",
        "output": "public void encryptAES_256_CTR_NoPadding() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"1234567812345678\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 256);\n        // 定义随机向量，也可以自定义\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 16);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.AES_CTR_NOPADDING);\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(iv);\n        mechanism.setParam(cbcParam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于AES-XTS算法，密钥长度为512，支持补位的加解密运算代码",
        "input": "",
        "output": "public void encryptAES_512_XTS() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"1234567812345678\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 512);\n        // 定义随机向量，也可以自定义\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 16);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.AES_XTS);\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(iv);\n        mechanism.setParam(cbcParam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于AES-XTS算法，密钥长度为512，不补位的加解密运算代码",
        "input": "",
        "output": "public void encryptAES_512_XTS_NoPadding() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"1234567812345678\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 512);\n        // 定义随机向量，也可以自定义\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 16);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.AES_XTS_NOPADDING);\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(iv);\n        mechanism.setParam(cbcParam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于AES-CCM算法，密钥长度为128的加解密运算代码",
        "input": "",
        "output": "public void encryptAES_128_CCM() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 128);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.AES_CCM_NOPADDING);\n        // 定义向量 AES_CCM算法中 初始化向量的长度必须在7到13字节之间\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 10);\n        // 设置加密机制参数\n        CCMParam ccmparam = new CCMParam();\n        ccmparam.setNonce(iv);\n        mechanism.setParam(ccmparam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于AES-CCM算法，密钥长度为192的加解密运算代码",
        "input": "",
        "output": "public void encryptAES_192_CCM() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 192);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.AES_CCM_NOPADDING);\n        // 定义向量 AES_CCM算法中 初始化向量的长度必须在7到13字节之间\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 10);\n        // 设置加密机制参数\n        CCMParam ccmparam = new CCMParam();\n        ccmparam.setNonce(iv);\n        mechanism.setParam(ccmparam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于AES-CCM算法，密钥长度为256的加解密运算代码",
        "input": "",
        "output": "public void encryptAES_256_CCM() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 256);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.AES_CCM_NOPADDING);\n        // 定义向量 AES_CCM算法中 初始化向量的长度必须在7到13字节之间\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 10);\n        // 设置加密机制参数\n        CCMParam ccmparam = new CCMParam();\n        ccmparam.setNonce(iv);\n        mechanism.setParam(ccmparam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写生成基于AES-CMC算法的消息认证码，并进行验证，密钥长度为128",
        "input": "",
        "output": "public void generateAndVerifyMacAES_128_CMAC() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 128);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.CMAC_AES);\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(\"0000000000000000\".getBytes());\n        mechanism.setParam(cbcParam);\n        // 生成消息认证码\n        byte[] macData = softSession.mac(mechanism, jkey, sourceData.getBytes());\n        // 验证消息认证码\n        boolean verify = softSession.verifyMac(mechanism, jkey, sourceData.getBytes(), macData);\n        System.out.println(\"验证结果：\" + verify + \" mac值为：\" + Base64.toBase64String(macData));\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写生成基于AES-CMC算法的消息认证码，并进行验证，密钥长度为192",
        "input": "",
        "output": "public void generateAndVerifyMacAES_192_CMAC() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 192);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.CMAC_AES);\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(\"0000000000000000\".getBytes());\n        mechanism.setParam(cbcParam);\n        // 生成消息认证码\n        byte[] macData = softSession.mac(mechanism, jkey, sourceData.getBytes());\n        // 验证消息认证码\n        boolean verify = softSession.verifyMac(mechanism, jkey, sourceData.getBytes(), macData);\n        System.out.println(\"验证结果：\" + verify + \" mac值为：\" + Base64.toBase64String(macData));\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写生成基于AES-CMC算法的消息认证码，并进行验证，密钥长度为256",
        "input": "",
        "output": "public void generateAndVerifyMacAES_256_CMAC() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.AES_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 256);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.CMAC_AES);\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(\"0000000000000000\".getBytes());\n        mechanism.setParam(cbcParam);\n        // 生成消息认证码\n        byte[] macData = softSession.mac(mechanism, jkey, sourceData.getBytes());\n        // 验证消息认证码\n        boolean verify = softSession.verifyMac(mechanism, jkey, sourceData.getBytes(), macData);\n        System.out.println(\"验证结果：\" + verify + \" mac值为：\" + Base64.toBase64String(macData));\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于DES-ECB算法，支持补位的对称加解密运算代码",
        "input": "",
        "output": "public void encryptDES_ECB() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.DES_KEY);\n        // 生成DES对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 64);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.DES_ECB);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于DES-ECB算法，不补位的对称加解密运算代码",
        "input": "",
        "output": "public void encryptDES_ECB_NoPadding() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"1234567812345678\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.DES_KEY);\n        // 生成DES对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 64);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.DES_ECB_NOPADDING);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于DES-CBC算法的加解密运算代码",
        "input": "",
        "output": "public void encryptDES_CBC() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.DES_KEY);\n        // 生成DES对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 64);\n        // 定义随机向量，也可以自定义\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 8);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.DES_CBC);\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(iv);\n        mechanism.setParam(cbcParam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于DES3_ECB算法,支持补位的加解密运算代码",
        "input": "",
        "output": "public void encryptDES3_ECB() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.DES3_KEY);\n        // 生成DES3对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 192);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.DES3_ECB);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于DES3_ECB算法,不支持补位的加解密运算代码",
        "input": "",
        "output": "public void encryptDES3_ECB_NoPadding() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"1234567812345678\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.DES3_KEY);\n        // 生成DES3对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 192);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.DES3_ECB_NOPADDING);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于DES3_CBC算法,支持补位的加解密运算代码",
        "input": "",
        "output": "public void encryptDES3_CBC() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.DES3_KEY);\n        // 生成DES3对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 192);\n        // 定义随机向量，也可以自定义\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 8);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.DES3_CBC);\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(iv);\n        mechanism.setParam(cbcParam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写基于DES3_CBC算法,不支持补位的加解密运算代码",
        "input": "",
        "output": "public void encryptDES3_CBC_NoPadding() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"1234567812345678\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.DES3_KEY);\n        // 生成DES3对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 192);\n        // 定义随机向量，也可以自定义\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 8);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.DES3_CBC_NOPADDING);\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(iv);\n        mechanism.setParam(cbcParam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写生成基于DES3-CMAC算法的消息认证码，并进行验证",
        "input": "",
        "output": "public void generateAndVerifyMacDES3_CMAC() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.DES3_KEY);\n        // 生成AES对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 192);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.CMAC_DES3);\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(\"0000000000000000\".getBytes());\n        mechanism.setParam(cbcParam);\n        // 生成消息认证码\n        byte[] macData = softSession.mac(mechanism, jkey, sourceData.getBytes());\n        // 验证消息认证码\n        boolean verify = softSession.verifyMac(mechanism, jkey, sourceData.getBytes(), macData);\n        System.out.println(\"验证结果：\" + verify + \" mac值为：\" + Base64.toBase64String(macData));\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写生成基于国密SM4-ECB算法，支持补位的加解密运算代码",
        "input": "",
        "output": "public void encryptSM4_ECB() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(JKey.SM4);\n        // 生成SM4对称密钥\n        JKey jkey = softSession.generateKey(mechanism, 128);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.SM4_ECB), jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.SM4_ECB), jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写生成基于国密SM4-ECB算法，不补位的加解密运算代码",
        "input": "",
        "output": "public void encryptSM4_ECB_NoPadding() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"1234567812345678\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(JKey.SM4);\n        // 生成SM4对称密钥\n        JKey jkey = softSession.generateKey(mechanism, 128);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.SM4_ECB_NOPADDING), jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.SM4_ECB_NOPADDING), jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于国密SM4-CBC算法，支持补位的加解密运算代码",
        "input": "",
        "output": "public void encryptSM4_CBC() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.SM4);\n        // 生成SM4对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 128);\n        // 定义随机向量，也可以自定义\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 16);\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(iv);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.SM4_CBC);\n        mechanism.setParam(cbcParam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于SM4-CBC算法，不补位的加解密运算代码",
        "input": "",
        "output": "public void encryptSM4_CBC_NoPadding() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文  CBC算法如果是不补位的情况下，那么原文数据长度需要为16字节的倍数\n    String sourceData = \"1234567812345678\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.SM4);\n        // 生成SM4对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 128);\n        // 定义随机向量，也可以自定义\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 16);\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(iv);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.SM4_CBC_NOPADDING);\n        mechanism.setParam(cbcParam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于SM4-GCM算法的加解密运算代码",
        "input": "",
        "output": "public void encryptSM4_GCM() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.SM4);\n        // 生成SM4对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 128);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.SM4_GCM_NOPADDING);\n        // 定义向量 SM4_GCM算法中 初始化向量的长度必须在1到16字节之间\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 12);\n        // 设置加密机制参数\n        CCMParam ccmparam = new CCMParam();\n        ccmparam.setNonce(iv);\n        mechanism.setParam(ccmparam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于SM4-CFB算法的加解密运算代码",
        "input": "",
        "output": "public void encryptSM4_CFB() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.SM4);\n        // 生成SM4对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 128);\n        // 定义随机向量，也可以自定义\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 16);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.SM4_CFB_NOPADDING);\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(iv);\n        mechanism.setParam(cbcParam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于SM4-CTR算法,支持补位的加解密运算代码",
        "input": "",
        "output": "public void encryptSM4_CTR() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.SM4);\n        // 生成SM4对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 128);\n        // 定义随机向量，也可以自定义\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 16);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.SM4_CTR);\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(iv);\n        mechanism.setParam(cbcParam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于SM4-CTR算法,不支持补位的加解密运算代码",
        "input": "",
        "output": "public void encryptSM4_CTR_NoPadding() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.SM4);\n        // 生成SM4对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 128);\n        // 定义随机向量，也可以自定义\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 16);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.SM4_CTR_NOPADDING);\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(iv);\n        mechanism.setParam(cbcParam);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(mechanism, jkey, sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(mechanism, jkey, encryptData);\n        System.out.println(\"解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现编写生成基于SM4-CMC算法的消息认证码，并进行验证",
        "input": "",
        "output": "public void generateAndVerifyMacSM4_CMAC() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism_key = new Mechanism(JKey.SM4);\n        // 生成SM4对称密钥\n        JKey jkey = softSession.generateKey(mechanism_key, 128);\n        // 定义加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.CMAC_SM4);\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(\"0000000000000000\".getBytes());\n        mechanism.setParam(cbcParam);\n        // 生成消息认证码\n        byte[] macData = softSession.mac(mechanism, jkey, sourceData.getBytes());\n        // 验证消息认证码\n        boolean verify = softSession.verifyMac(mechanism, jkey, sourceData.getBytes(), macData);\n        System.out.println(\"验证结果：\" + verify + \" mac值为：\" + Base64.toBase64String(macData));\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现生成基于AES算法，密钥长度为128的外部对称密钥对",
        "input": "",
        "output": "public void generateAES128Key() {\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(JKey.AES_KEY);\n        JKey jkey = softSession.generateKey(mechanism, 128);\n        String temp = java.util.Base64.getEncoder().encodeToString(jkey.getKey());\n        System.out.println(temp);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现生成基于AES算法，密钥长度为192的外部对称密钥对",
        "input": "",
        "output": "public void generateAES192Key() {\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(JKey.AES_KEY);\n        JKey jkey = softSession.generateKey(mechanism, 192);\n        String temp = java.util.Base64.getEncoder().encodeToString(jkey.getKey());\n        System.out.println(temp);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现生成基于AES算法，密钥长度为256的外部对称密钥对",
        "input": "",
        "output": "public void generateAES256Key() {\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(JKey.AES_KEY);\n        JKey jkey = softSession.generateKey(mechanism, 256);\n        String temp = java.util.Base64.getEncoder().encodeToString(jkey.getKey());\n        System.out.println(temp);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现生成基于DES算法的外部对称密钥对",
        "input": "",
        "output": "public void generateDESKey() {\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(JKey.DES_KEY);\n        JKey jkey = softSession.generateKey(mechanism, 64);\n        String temp = java.util.Base64.getEncoder().encodeToString(jkey.getKey());\n        System.out.println(temp);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现生成基于3DES算法的外部对称密钥对",
        "input": "",
        "output": "public void generate3DESKey() {\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(JKey.DES3_KEY);\n        JKey jkey = softSession.generateKey(mechanism, 192);\n        String temp = java.util.Base64.getEncoder().encodeToString(jkey.getKey());\n        System.out.println(temp);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现生成基于SM4算法的外部对称密钥对",
        "input": "",
        "output": "public void generateSM4Key() {\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(JKey.SM4);\n        JKey jkey = softSession.generateKey(mechanism, 128);\n        String temp = java.util.Base64.getEncoder().encodeToString(jkey.getKey());\n        System.out.println(temp);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA_PKCS,密钥长度为1024的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_PKCS_1024() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 1024);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_PKCS), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作 RSA_PKCS与RSA的区别：RSA_PKCS是指使用RSA加密算法时，按照PKCS（Public Key Cryptography\n        // Standards）标准对数据进行填充，标准名称：PKCS#1 v1.5 相比RSA更安全\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_PKCS), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA_PKCS,密钥长度为3072的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_PKCS_3072() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 3072);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_PKCS), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_PKCS), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA_PKCS,密钥长度为4096的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_PKCS_4096() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 4096);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_PKCS), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_PKCS), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,密钥长度为1024的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_1024() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 1024);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,密钥长度为2048的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_2048() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 2048);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,密钥长度为3072的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_3072() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 3072);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,密钥长度为4096的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_4096() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 4096);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA1作为哈希函数，MGF1作为随机生成函数，密钥长度为1024的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_OAEP_SHA1_MGF1_1024() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 1024);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA1_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA1_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA1作为哈希函数，MGF1作为随机生成函数，密钥长度为2048的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_OAEP_SHA1_MGF1_2048() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 2048);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA1_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA1_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA1作为哈希函数，MGF1作为随机生成函数，密钥长度为3072的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_OAEP_SHA1_MGF1_3072() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 3072);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA1_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA1_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA1作为哈希函数，MGF1作为随机生成函数，密钥长度为4096的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_OAEP_SHA1_MGF1_4096() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 4096);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA1_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA1_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA224作为哈希函数，MGF1作为随机生成函数，密钥长度为1024的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_OAEP_SHA224_MGF1_1024() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 1024);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA224_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA224_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA224作为哈希函数，MGF1作为随机生成函数，密钥长度为2048的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_OAEP_SHA224_MGF1_2048() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 2048);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA224_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA224_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA224作为哈希函数，MGF1作为随机生成函数，密钥长度为3072的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_OAEP_SHA224_MGF1_3072() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 3072);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA224_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA224_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA224作为哈希函数，MGF1作为随机生成函数，密钥长度为4096的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_OAEP_SHA224_MGF1_4096() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 4096);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA224_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA224_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA256作为哈希函数，MGF1作为随机生成函数，密钥长度为1024的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_OAEP_SHA256_MGF1_1024() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 1024);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA256_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA256_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA256作为哈希函数，MGF1作为随机生成函数，密钥长度为2048的加解密运算代码",
        "input": "",
        "output": "/**\n *     请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA256作为哈希函数，MGF1作为随机生成函数，密钥长度为2048的加解密运算代码，\n *     即使用RSA/ECB/OAEPWithSHA256AndMGF1Padding 算法实现加解密的代码\n */\npublic void encryptRSA_OAEP_SHA256_MGF1_2048() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 2048);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA256_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA256_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA256作为哈希函数，MGF1作为随机生成函数，密钥长度为3072的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_OAEP_SHA256_MGF1_3072() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 3072);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA256_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA256_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA256作为哈希函数，MGF1作为随机生成函数，密钥长度为4096的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_OAEP_SHA256_MGF1_4096() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 4096);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA256_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA256_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA384作为哈希函数，MGF1作为随机生成函数，密钥长度为1024的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_OAEP_SHA384_MGF1_1024() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 1024);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA384_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA384_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA384作为哈希函数，MGF1作为随机生成函数，密钥长度为2048的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_OAEP_SHA384_MGF1_2048() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 2048);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA384_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA384_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA256作为哈希函数，MGF1作为随机生成函数，密钥长度为3072的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_OAEP_SHA384_MGF1_3072() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 3072);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA384_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA384_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA384作为哈希函数，MGF1作为随机生成函数，密钥长度为4096的加解密运算代码",
        "input": "",
        "output": "/**\n *     请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA384作为哈希函数，MGF1作为随机生成函数，密钥长度为4096的加解密运算代码，\n *     即使用RSA/ECB/OAEPWithSHA256AndMGF1Padding 算法实现加解密的代码\n */\npublic void encryptRSA_OAEP_SHA384_MGF1_4096() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 4096);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA384_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA384_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA512作为哈希函数，MGF1作为随机生成函数，密钥长度为1024的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_OAEP_SHA512_MGF1_1024() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 1024);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA512_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA512_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA512作为哈希函数，MGF1作为随机生成函数，密钥长度为2048的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_OAEP_SHA512_MGF1_2048() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 2048);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA512_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA512_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA512作为哈希函数，MGF1作为随机生成函数，密钥长度为3072的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_OAEP_SHA512_MGF1_3072() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 3072);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA512_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA512_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA512作为哈希函数，MGF1作为随机生成函数，密钥长度为4096的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_OAEP_SHA512_MGF1_4096() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 4096);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA512_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA512_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA3_224作为哈希函数，MGF1作为随机生成函数，密钥长度为1024的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_OAEP_SHA3_224_MGF1_1024() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 1024);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA3_224_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA3_224_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA3_224作为哈希函数，MGF1作为随机生成函数，密钥长度为2048的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_OAEP_SHA3_224_MGF1_2048() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 2048);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA3_224_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA3_224_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA3_224作为哈希函数，MGF1作为随机生成函数，密钥长度为3072的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_OAEP_SHA3_224_MGF1_3072() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 3072);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA3_224_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA3_224_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA3_224作为哈希函数，MGF1作为随机生成函数，密钥长度为4096的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_OAEP_SHA3_224_MGF1_4096() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 4096);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA3_224_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA3_224_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA3_256作为哈希函数，MGF1作为随机生成函数，密钥长度为1024的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_OAEP_SHA3_256_MGF1_1024() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 1024);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA3_256_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA3_256_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA3_256作为哈希函数，MGF1作为随机生成函数，密钥长度为2048的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_OAEP_SHA3_256_MGF1_2048() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 2048);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA3_256_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA3_256_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA3_256作为哈希函数，MGF1作为随机生成函数，密钥长度为3072的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_OAEP_SHA3_256_MGF1_3072() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 3072);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA3_256_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA3_256_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA3_256作为哈希函数，MGF1作为随机生成函数，密钥长度为4096的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_OAEP_SHA3_256_MGF1_4096() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 4096);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA3_256_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA3_256_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA3_384作为哈希函数，MGF1作为随机生成函数，密钥长度为1024的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_OAEP_SHA3_384_MGF1_1024() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 1024);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA3_384_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA3_384_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA3_384作为哈希函数，MGF1作为随机生成函数，密钥长度为2048的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_OAEP_SHA3_384_MGF1_2048() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 2048);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA3_384_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA3_384_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA3_384作为哈希函数，MGF1作为随机生成函数，密钥长度为3072的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_OAEP_SHA3_384_MGF1_3072() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 3072);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA3_384_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA3_384_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA3_384作为哈希函数，MGF1作为随机生成函数，密钥长度为4096的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_OAEP_SHA3_384_MGF1_4096() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 4096);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA3_384_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA3_384_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA3_512作为哈希函数，MGF1作为随机生成函数，密钥长度为1024的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_OAEP_SHA3_512_MGF1_1024() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 1024);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA3_512_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA3_512_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA3_512作为哈希函数，MGF1作为随机生成函数，密钥长度为2048的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_OAEP_SHA3_512_MGF1_2048() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 2048);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA3_512_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA3_512_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA3_512作为哈希函数，MGF1作为随机生成函数，密钥长度为3072的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_OAEP_SHA3_512_MGF1_3072() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 3072);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA3_512_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA3_512_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法RSA,采用OAEP填充方式，SHA3_512作为哈希函数，MGF1作为随机生成函数，密钥长度为4096的加解密运算代码",
        "input": "",
        "output": "public void encryptRSA_OAEP_SHA3_512_MGF1_4096() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 4096);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.RSA_OAEP_SHA3_512_MGF1PADDING), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.RSA_OAEP_SHA3_512_MGF1PADDING), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于非对称算法SM2加解密运算代码，",
        "input": "",
        "output": "public void encryptSM2() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 定义待加密原文\n    String sourceData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.SM2);\n        // 生成RSA对称密钥\n        JKeyPair jkeyPair = softSession.generateKeyPair(mechanism, 256);\n        // 加密操作\n        byte[] encryptData = softSession.encrypt(new Mechanism(Mechanism.SM2_RAW), jkeyPair.getPublicKey(), sourceData.getBytes());\n        // 解密操作\n        byte[] decryptData = softSession.decrypt(new Mechanism(Mechanism.SM2_RAW), jkeyPair.getPrivateKey(), encryptData);\n        System.out.println(\"加密后数据：\" + Base64.toBase64String(encryptData) + \"  解密后数据：\" + new String(decryptData) + \"   数据原文：\" + sourceData);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于SHA1_RSA算法的签名验签代码，RSA密钥长度为1024",
        "input": "",
        "output": "public void signAndVerfiyWithSHA1_RSA_1024() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    String srcData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成密钥对，JKeyPair为非对称密钥对\n        JKeyPair keypair = softSession.generateKeyPair(mechanism, 1024);\n        // 签名\n        byte[] signData = softSession.sign(new Mechanism(Mechanism.SHA1_RSA), keypair.getPrivateKey(), srcData.getBytes());\n        System.out.println(\"======= 签名值为：\" + \"  \" + Base64.encodeToString(signData) + \" ========\");\n        // 验签\n        boolean success = softSession.verifySign(new Mechanism(Mechanism.SHA1_RSA), keypair.getPublicKey(), srcData.getBytes(), signData);\n        System.out.println(\"验签状态: \" + success);\n    } catch (PKIException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于SHA1_RSA算法的签名验签代码，RSA密钥长度为2048",
        "input": "",
        "output": "public void signAndVerfiyWithSHA1_RSA_2048() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    String srcData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成密钥对，JKeyPair为非对称密钥对\n        JKeyPair keypair = softSession.generateKeyPair(mechanism, 2048);\n        // 签名\n        byte[] signData = softSession.sign(new Mechanism(Mechanism.SHA1_RSA), keypair.getPrivateKey(), srcData.getBytes());\n        System.out.println(\"======= 签名值为：\" + \"  \" + Base64.encodeToString(signData) + \" ========\");\n        // 验签\n        boolean success = softSession.verifySign(new Mechanism(Mechanism.SHA1_RSA), keypair.getPublicKey(), srcData.getBytes(), signData);\n        System.out.println(\"验签状态: \" + success);\n    } catch (PKIException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于SHA1_RSA算法的签名验签代码，RSA密钥长度为3072",
        "input": "",
        "output": "public void signAndVerfiyWithSHA1_RSA_3072() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    String srcData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成密钥对，JKeyPair为非对称密钥对\n        JKeyPair keypair = softSession.generateKeyPair(mechanism, 3072);\n        // 签名\n        byte[] signData = softSession.sign(new Mechanism(Mechanism.SHA1_RSA), keypair.getPrivateKey(), srcData.getBytes());\n        System.out.println(\"======= 签名值为：\" + \"  \" + Base64.encodeToString(signData) + \" ========\");\n        // 验签\n        boolean success = softSession.verifySign(new Mechanism(Mechanism.SHA1_RSA), keypair.getPublicKey(), srcData.getBytes(), signData);\n        System.out.println(\"验签状态: \" + success);\n    } catch (PKIException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于SHA1_RSA算法的签名验签代码，RSA密钥长度为4096",
        "input": "",
        "output": "public void signAndVerfiyWithSHA1_RSA_4096() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    String srcData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成密钥对，JKeyPair为非对称密钥对\n        JKeyPair keypair = softSession.generateKeyPair(mechanism, 4096);\n        // 签名\n        byte[] signData = softSession.sign(new Mechanism(Mechanism.SHA1_RSA), keypair.getPrivateKey(), srcData.getBytes());\n        System.out.println(\"======= 签名值为：\" + \"  \" + Base64.encodeToString(signData) + \" ========\");\n        // 验签\n        boolean success = softSession.verifySign(new Mechanism(Mechanism.SHA1_RSA), keypair.getPublicKey(), srcData.getBytes(), signData);\n        System.out.println(\"验签状态: \" + success);\n    } catch (PKIException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于SHA224_RSA算法的签名验签代码，RSA密钥长度为1024",
        "input": "",
        "output": "public void signAndVerfiyWithSHA224_RSA_1024() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    String srcData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成密钥对，JKeyPair为非对称密钥对\n        JKeyPair keypair = softSession.generateKeyPair(mechanism, 1024);\n        // 签名\n        byte[] signData = softSession.sign(new Mechanism(Mechanism.SHA224_RSA), keypair.getPrivateKey(), srcData.getBytes());\n        System.out.println(\"======= 签名值为：\" + \"  \" + Base64.encodeToString(signData) + \" ========\");\n        // 验签\n        boolean success = softSession.verifySign(new Mechanism(Mechanism.SHA224_RSA), keypair.getPublicKey(), srcData.getBytes(), signData);\n        System.out.println(\"验签状态: \" + success);\n    } catch (PKIException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于SHA224_RSA算法的签名验签代码，RSA密钥长度为2048",
        "input": "",
        "output": "public void signAndVerfiyWithSHA224_RSA_2048() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    String srcData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成密钥对，JKeyPair为非对称密钥对\n        JKeyPair keypair = softSession.generateKeyPair(mechanism, 2048);\n        // 签名\n        byte[] signData = softSession.sign(new Mechanism(Mechanism.SHA224_RSA), keypair.getPrivateKey(), srcData.getBytes());\n        System.out.println(\"======= 签名值为：\" + \"  \" + Base64.encodeToString(signData) + \" ========\");\n        // 验签\n        boolean success = softSession.verifySign(new Mechanism(Mechanism.SHA224_RSA), keypair.getPublicKey(), srcData.getBytes(), signData);\n        System.out.println(\"验签状态: \" + success);\n    } catch (PKIException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于SHA224_RSA算法的签名验签代码，RSA密钥长度为3072",
        "input": "",
        "output": "public void signAndVerfiyWithSHA224_RSA_3072() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    String srcData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成密钥对，JKeyPair为非对称密钥对\n        JKeyPair keypair = softSession.generateKeyPair(mechanism, 3072);\n        // 签名\n        byte[] signData = softSession.sign(new Mechanism(Mechanism.SHA224_RSA), keypair.getPrivateKey(), srcData.getBytes());\n        System.out.println(\"======= 签名值为：\" + \"  \" + Base64.encodeToString(signData) + \" ========\");\n        // 验签\n        boolean success = softSession.verifySign(new Mechanism(Mechanism.SHA224_RSA), keypair.getPublicKey(), srcData.getBytes(), signData);\n        System.out.println(\"验签状态: \" + success);\n    } catch (PKIException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于SHA224_RSA算法的签名验签代码，RSA密钥长度为4096",
        "input": "",
        "output": "public void signAndVerfiyWithSHA224_RSA_4096() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    String srcData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成密钥对，JKeyPair为非对称密钥对\n        JKeyPair keypair = softSession.generateKeyPair(mechanism, 4096);\n        // 签名\n        byte[] signData = softSession.sign(new Mechanism(Mechanism.SHA224_RSA), keypair.getPrivateKey(), srcData.getBytes());\n        System.out.println(\"======= 签名值为：\" + \"  \" + Base64.encodeToString(signData) + \" ========\");\n        // 验签\n        boolean success = softSession.verifySign(new Mechanism(Mechanism.SHA224_RSA), keypair.getPublicKey(), srcData.getBytes(), signData);\n        System.out.println(\"验签状态: \" + success);\n    } catch (PKIException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于SHA256_RSA算法的签名验签代码，RSA密钥长度为1024",
        "input": "",
        "output": "public void signAndVerfiyWithSHA256_RSA_1024() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    String srcData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成密钥对，JKeyPair为非对称密钥对\n        JKeyPair keypair = softSession.generateKeyPair(mechanism, 1024);\n        // 签名\n        byte[] signData = softSession.sign(new Mechanism(Mechanism.SHA256_RSA), keypair.getPrivateKey(), srcData.getBytes());\n        System.out.println(\"======= 签名值为：\" + \"  \" + Base64.encodeToString(signData) + \" ========\");\n        // 验签\n        boolean success = softSession.verifySign(new Mechanism(Mechanism.SHA256_RSA), keypair.getPublicKey(), srcData.getBytes(), signData);\n        System.out.println(\"验签状态: \" + success);\n    } catch (PKIException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于SHA256_RSA算法的签名验签代码，RSA密钥长度为2048",
        "input": "",
        "output": "public void signAndVerfiyWithSHA256_RSA_2048() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    String srcData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成密钥对，JKeyPair为非对称密钥对\n        JKeyPair keypair = softSession.generateKeyPair(mechanism, 2048);\n        // 签名\n        byte[] signData = softSession.sign(new Mechanism(Mechanism.SHA256_RSA), keypair.getPrivateKey(), srcData.getBytes());\n        System.out.println(\"======= 签名值为：\" + \"  \" + Base64.encodeToString(signData) + \" ========\");\n        // 验签\n        boolean success = softSession.verifySign(new Mechanism(Mechanism.SHA256_RSA), keypair.getPublicKey(), srcData.getBytes(), signData);\n        System.out.println(\"验签状态: \" + success);\n    } catch (PKIException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于SHA256_RSA算法的签名验签代码，RSA密钥长度为3072",
        "input": "",
        "output": "public void signAndVerfiyWithSHA256_RSA_3072() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    String srcData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成密钥对，JKeyPair为非对称密钥对\n        JKeyPair keypair = softSession.generateKeyPair(mechanism, 3072);\n        // 签名\n        byte[] signData = softSession.sign(new Mechanism(Mechanism.SHA256_RSA), keypair.getPrivateKey(), srcData.getBytes());\n        System.out.println(\"======= 签名值为：\" + \"  \" + Base64.encodeToString(signData) + \" ========\");\n        // 验签\n        boolean success = softSession.verifySign(new Mechanism(Mechanism.SHA256_RSA), keypair.getPublicKey(), srcData.getBytes(), signData);\n        System.out.println(\"验签状态: \" + success);\n    } catch (PKIException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于SHA256_RSA算法的签名验签代码，RSA密钥长度为4096",
        "input": "",
        "output": "public void signAndVerfiyWithSHA256_RSA_4096() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    String srcData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成密钥对，JKeyPair为非对称密钥对\n        JKeyPair keypair = softSession.generateKeyPair(mechanism, 4096);\n        // 签名\n        byte[] signData = softSession.sign(new Mechanism(Mechanism.SHA256_RSA), keypair.getPrivateKey(), srcData.getBytes());\n        System.out.println(\"======= 签名值为：\" + \"  \" + Base64.encodeToString(signData) + \" ========\");\n        // 验签\n        boolean success = softSession.verifySign(new Mechanism(Mechanism.SHA256_RSA), keypair.getPublicKey(), srcData.getBytes(), signData);\n        System.out.println(\"验签状态: \" + success);\n    } catch (PKIException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于SHA384_RSA算法的签名验签代码，RSA密钥长度为1024",
        "input": "",
        "output": "public void signAndVerfiyWithSHA384_RSA_1024() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    String srcData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成密钥对，JKeyPair为非对称密钥对\n        JKeyPair keypair = softSession.generateKeyPair(mechanism, 1024);\n        // 签名\n        byte[] signData = softSession.sign(new Mechanism(Mechanism.SHA384_RSA), keypair.getPrivateKey(), srcData.getBytes());\n        System.out.println(\"======= 签名值为：\" + \"  \" + Base64.encodeToString(signData) + \" ========\");\n        // 验签\n        boolean success = softSession.verifySign(new Mechanism(Mechanism.SHA384_RSA), keypair.getPublicKey(), srcData.getBytes(), signData);\n        System.out.println(\"验签状态: \" + success);\n    } catch (PKIException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于SHA384_RSA算法的签名验签代码，RSA密钥长度为2048",
        "input": "",
        "output": "public void signAndVerfiyWithSHA384_RSA_2048() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    String srcData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成密钥对，JKeyPair为非对称密钥对\n        JKeyPair keypair = softSession.generateKeyPair(mechanism, 2048);\n        // 签名\n        byte[] signData = softSession.sign(new Mechanism(Mechanism.SHA384_RSA), keypair.getPrivateKey(), srcData.getBytes());\n        System.out.println(\"======= 签名值为：\" + \"  \" + Base64.encodeToString(signData) + \" ========\");\n        // 验签\n        boolean success = softSession.verifySign(new Mechanism(Mechanism.SHA384_RSA), keypair.getPublicKey(), srcData.getBytes(), signData);\n        System.out.println(\"验签状态: \" + success);\n    } catch (PKIException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于SHA384_RSA算法的签名验签代码，RSA密钥长度为3072",
        "input": "",
        "output": "public void signAndVerfiyWithSHA384_RSA_3072() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    String srcData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成密钥对，JKeyPair为非对称密钥对\n        JKeyPair keypair = softSession.generateKeyPair(mechanism, 3072);\n        // 签名\n        byte[] signData = softSession.sign(new Mechanism(Mechanism.SHA384_RSA), keypair.getPrivateKey(), srcData.getBytes());\n        System.out.println(\"======= 签名值为：\" + \"  \" + Base64.encodeToString(signData) + \" ========\");\n        // 验签\n        boolean success = softSession.verifySign(new Mechanism(Mechanism.SHA384_RSA), keypair.getPublicKey(), srcData.getBytes(), signData);\n        System.out.println(\"验签状态: \" + success);\n    } catch (PKIException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于SHA384_RSA算法的签名验签代码，RSA密钥长度为4096",
        "input": "",
        "output": "public void signAndVerfiyWithSHA384_RSA_4096() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    String srcData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成密钥对，JKeyPair为非对称密钥对\n        JKeyPair keypair = softSession.generateKeyPair(mechanism, 4096);\n        // 签名\n        byte[] signData = softSession.sign(new Mechanism(Mechanism.SHA384_RSA), keypair.getPrivateKey(), srcData.getBytes());\n        System.out.println(\"======= 签名值为：\" + \"  \" + Base64.encodeToString(signData) + \" ========\");\n        // 验签\n        boolean success = softSession.verifySign(new Mechanism(Mechanism.SHA384_RSA), keypair.getPublicKey(), srcData.getBytes(), signData);\n        System.out.println(\"验签状态: \" + success);\n    } catch (PKIException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于SHA512_RSA算法的签名验签代码，RSA密钥长度为1024",
        "input": "",
        "output": "public void signAndVerfiyWithSHA512_RSA_1024() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    String srcData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成密钥对，JKeyPair为非对称密钥对\n        JKeyPair keypair = softSession.generateKeyPair(mechanism, 1024);\n        // 签名\n        byte[] signData = softSession.sign(new Mechanism(Mechanism.SHA512_RSA), keypair.getPrivateKey(), srcData.getBytes());\n        System.out.println(\"======= 签名值为：\" + \"  \" + Base64.encodeToString(signData) + \" ========\");\n        // 验签\n        boolean success = softSession.verifySign(new Mechanism(Mechanism.SHA512_RSA), keypair.getPublicKey(), srcData.getBytes(), signData);\n        System.out.println(\"验签状态: \" + success);\n    } catch (PKIException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于SHA512_RSA算法的签名验签代码，RSA密钥长度为2048",
        "input": "",
        "output": "public void signAndVerfiyWithSHA512_RSA_2048() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    String srcData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成密钥对，JKeyPair为非对称密钥对\n        JKeyPair keypair = softSession.generateKeyPair(mechanism, 2048);\n        // 签名\n        byte[] signData = softSession.sign(new Mechanism(Mechanism.SHA512_RSA), keypair.getPrivateKey(), srcData.getBytes());\n        System.out.println(\"======= 签名值为：\" + \"  \" + Base64.encodeToString(signData) + \" ========\");\n        // 验签\n        boolean success = softSession.verifySign(new Mechanism(Mechanism.SHA512_RSA), keypair.getPublicKey(), srcData.getBytes(), signData);\n        System.out.println(\"验签状态: \" + success);\n    } catch (PKIException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于SHA512_RSA算法的签名验签代码，RSA密钥长度为3072",
        "input": "",
        "output": "public void signAndVerfiyWithSHA512_RSA_3072() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    String srcData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成密钥对，JKeyPair为非对称密钥对\n        JKeyPair keypair = softSession.generateKeyPair(mechanism, 3072);\n        // 签名\n        byte[] signData = softSession.sign(new Mechanism(Mechanism.SHA512_RSA), keypair.getPrivateKey(), srcData.getBytes());\n        System.out.println(\"======= 签名值为：\" + \"  \" + Base64.encodeToString(signData) + \" ========\");\n        // 验签\n        boolean success = softSession.verifySign(new Mechanism(Mechanism.SHA512_RSA), keypair.getPublicKey(), srcData.getBytes(), signData);\n        System.out.println(\"验签状态: \" + success);\n    } catch (PKIException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于SHA512_RSA算法的签名验签代码，RSA密钥长度为4096",
        "input": "",
        "output": "public void signAndVerfiyWithSHA512_RSA_4096() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    String srcData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(Mechanism.RSA);\n        // 生成密钥对，JKeyPair为非对称密钥对\n        JKeyPair keypair = softSession.generateKeyPair(mechanism, 4096);\n        // 签名\n        byte[] signData = softSession.sign(new Mechanism(Mechanism.SHA512_RSA), keypair.getPrivateKey(), srcData.getBytes());\n        System.out.println(\"======= 签名值为：\" + \"  \" + Base64.encodeToString(signData) + \" ========\");\n        // 验签\n        boolean success = softSession.verifySign(new Mechanism(Mechanism.SHA512_RSA), keypair.getPublicKey(), srcData.getBytes(), signData);\n        System.out.println(\"验签状态: \" + success);\n    } catch (PKIException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于椭圆曲线secp256r1的SHA256_EC_DSA算法的签名验签代码",
        "input": "",
        "output": "public void signAndVerfiyWithSHA256_EC_DSA() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    String srcData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(Mechanism.SECP256_r1);\n        // 生成密钥对，JKeyPair为非对称密钥对\n        JKeyPair keypair = softSession.generateKeyPair(mechanism, 256);\n        // 签名\n        byte[] signData = softSession.sign(new Mechanism(Mechanism.SHA256_EC_DSA), keypair.getPrivateKey(), srcData.getBytes());\n        System.out.println(\"======= 签名值为：\" + \"  \" + Base64.encodeToString(signData) + \" ========\");\n        // 验签\n        boolean success = softSession.verifySign(new Mechanism(Mechanism.SHA256_EC_DSA), keypair.getPublicKey(), srcData.getBytes(), signData);\n        System.out.println(\"验签状态: \" + success);\n    } catch (PKIException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于椭圆曲线secp256r1的SHA384_EC_DSA算法的签名验签代码",
        "input": "",
        "output": "public void signAndVerfiyWithSHA384_EC_DSA() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    String srcData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(Mechanism.SECP256_r1);\n        // 生成密钥对，JKeyPair为非对称密钥对\n        JKeyPair keypair = softSession.generateKeyPair(mechanism, 256);\n        // 签名\n        byte[] signData = softSession.sign(new Mechanism(Mechanism.SHA384_EC_DSA), keypair.getPrivateKey(), srcData.getBytes());\n        System.out.println(\"======= 签名值为：\" + \"  \" + Base64.encodeToString(signData) + \" ========\");\n        // 验签\n        boolean success = softSession.verifySign(new Mechanism(Mechanism.SHA384_EC_DSA), keypair.getPublicKey(), srcData.getBytes(), signData);\n        System.out.println(\"验签状态: \" + success);\n    } catch (PKIException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于椭圆曲线secp256r1的SHA512_EC_DSA算法的签名验签代码",
        "input": "",
        "output": "public void signAndVerfiyWithSHA512_EC_DSA() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    String srcData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(Mechanism.SECP256_r1);\n        // 生成密钥对，JKeyPair为非对称密钥对\n        JKeyPair keypair = softSession.generateKeyPair(mechanism, 256);\n        // 签名\n        byte[] signData = softSession.sign(new Mechanism(Mechanism.SHA512_EC_DSA), keypair.getPrivateKey(), srcData.getBytes());\n        System.out.println(\"======= 签名值为：\" + \"  \" + Base64.encodeToString(signData) + \" ========\");\n        // 验签\n        boolean success = softSession.verifySign(new Mechanism(Mechanism.SHA512_EC_DSA), keypair.getPublicKey(), srcData.getBytes(), signData);\n        System.out.println(\"验签状态: \" + success);\n    } catch (PKIException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于SM3_SM2算法的签名验签代码",
        "input": "",
        "output": "public void signAndVerfiyWithSM3_SM2() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    String srcData = \"Hello World\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(Mechanism.SM2);\n        // 生成密钥对，JKeyPair为非对称密钥对\n        JKeyPair keypair = softSession.generateKeyPair(mechanism, 256);\n        // 签名\n        byte[] signData = softSession.sign(new Mechanism(Mechanism.SM3_SM2), keypair.getPrivateKey(), srcData.getBytes());\n        System.out.println(\"======= 签名值为：\" + \"  \" + Base64.encodeToString(signData) + \" ========\");\n        // 验签\n        boolean success = softSession.verifySign(new Mechanism(Mechanism.SM3_SM2), keypair.getPublicKey(), srcData.getBytes(), signData);\n        System.out.println(\"验签状态: \" + success);\n    } catch (PKIException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于ECDH算法secp256r1曲线的密钥协商代码",
        "input": "",
        "output": "public void ecdhWithECDH_SECP256R1() {\n    // 创建实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 创建会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 定义密钥生成加密机制\n        Mechanism mechanism_key = new Mechanism(Mechanism.SECP256_r1);\n        //创建密钥对A\n        JKeyPair jKeyPair_A = softSession.generateKeyPair(mechanism_key, 256);\n        //创建密钥对B\n        JKeyPair jKeyPair_B = softSession.generateKeyPair(mechanism_key, 256);\n        //定义密钥协商加密机制\n        Mechanism mechanism_ecdh = new Mechanism(Mechanism.ECDH);\n        //使用A密钥对的私钥与B密钥对的公钥进行密钥协商\n        byte[] secretKey_A = softSession.keyAgreement(mechanism_ecdh, jKeyPair_B.getPublicKey(), jKeyPair_A.getPrivateKey(), 0);\n        //使用B密钥对的私钥与A密钥对的公钥进行密钥协商\n        byte[] secretKey_B = softSession.keyAgreement(mechanism_ecdh, jKeyPair_A.getPublicKey(), jKeyPair_B.getPrivateKey(), 0);\n        //验证密钥协商是否一致\n        if (secretKey_A != null && secretKey_B != null) {\n            boolean success = Arrays.equals(secretKey_A, secretKey_B);\n            System.out.println(\"密钥协商是否成功: \" + success);\n        } else {\n            System.out.println(\"密钥协商失败\");\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于SHA1算法的摘要代码",
        "input": "",
        "output": "public void digestWithSHA1() {\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 摘要算法\n        Mechanism mechanism = new Mechanism(Mechanism.SHA1);\n        // 摘要数据\n        byte[] srcData = \"Hello World\".getBytes();\n        // 计算摘要\n        byte[] digestData = softSession.digest(mechanism, srcData);\n        String temp = java.util.Base64.getEncoder().encodeToString(digestData);\n        System.out.println(\"生成摘要：\" + temp);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于SHA224算法的摘要代码",
        "input": "",
        "output": "public void digestWithSHA224() {\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 摘要算法\n        Mechanism mechanism = new Mechanism(Mechanism.SHA224);\n        // 摘要数据\n        byte[] srcData = \"Hello World\".getBytes();\n        // 计算摘要\n        byte[] digestData = softSession.digest(mechanism, srcData);\n        String temp = java.util.Base64.getEncoder().encodeToString(digestData);\n        System.out.println(\"生成摘要：\" + temp);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于SHA256算法的摘要代码",
        "input": "",
        "output": "public void digestWithSHA256() {\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 摘要算法\n        Mechanism mechanism = new Mechanism(Mechanism.SHA256);\n        // 摘要数据\n        byte[] srcData = \"Hello World\".getBytes();\n        // 计算摘要\n        byte[] digestData = softSession.digest(mechanism, srcData);\n        String temp = java.util.Base64.getEncoder().encodeToString(digestData);\n        System.out.println(\"生成摘要：\" + temp);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于SHA384算法的摘要代码",
        "input": "",
        "output": "public void digestWithSHA384() {\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 摘要算法\n        Mechanism mechanism = new Mechanism(Mechanism.SHA384);\n        // 摘要数据\n        byte[] srcData = \"Hello World\".getBytes();\n        // 计算摘要\n        byte[] digestData = softSession.digest(mechanism, srcData);\n        String temp = java.util.Base64.getEncoder().encodeToString(digestData);\n        System.out.println(\"生成摘要：\" + temp);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于SHA512算法的摘要代码",
        "input": "",
        "output": "public void digestWithSHA512() {\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 摘要算法\n        Mechanism mechanism = new Mechanism(Mechanism.SHA512);\n        // 摘要数据\n        byte[] srcData = \"Hello World\".getBytes();\n        // 计算摘要\n        byte[] digestData = softSession.digest(mechanism, srcData);\n        String temp = java.util.Base64.getEncoder().encodeToString(digestData);\n        System.out.println(\"生成摘要：\" + temp);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于SM3算法的摘要代码",
        "input": "",
        "output": "public void digestWithSM3() {\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 摘要算法\n        Mechanism mechanism = new Mechanism(Mechanism.SM3);\n        // 摘要数据\n        byte[] srcData = \"Hello World\".getBytes();\n        // 计算摘要\n        byte[] digestData = softSession.digest(mechanism, srcData);\n        String temp = java.util.Base64.getEncoder().encodeToString(digestData);\n        System.out.println(\"生成摘要：\" + temp);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于MD5算法的摘要代码",
        "input": "",
        "output": "public void digestWithMD5() {\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 摘要算法\n        Mechanism mechanism = new Mechanism(Mechanism.MD5);\n        // 摘要数据\n        byte[] srcData = \"Hello World\".getBytes();\n        // 计算摘要\n        byte[] digestData = softSession.digest(mechanism, srcData);\n        String temp = java.util.Base64.getEncoder().encodeToString(digestData);\n        System.out.println(\"生成摘要：\" + temp);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现生成随机数",
        "input": "",
        "output": "public void generateRandom() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        Mechanism mechanism = new Mechanism(Mechanism.RANDOM);\n        //定义随机数长度\n        int dataLen = 16;\n        byte[] random = softSession.generateRandom(mechanism, dataLen);\n        String temp = java.util.Base64.getEncoder().encodeToString(random);\n        System.out.println(temp);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于HMAC-SHA256算法的MAC代码",
        "input": "",
        "output": "public void mackWithHMAC_SHA256() {\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        //HMAC原文\n        String srcData = \"这是一段数据原文\";\n        // 创建密钥加密机制\n        Mechanism mechanism_key = new Mechanism(Mechanism.AES_KEY);\n        JKey jkey = softSession.generateKey(mechanism_key, 64);\n        // 创建HMAC加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.HMAC_SHA256);\n        byte[] hmac_result = softSession.mac(mechanism, jkey, srcData.getBytes());\n        String hmacBase64String = Base64.toBase64String(hmac_result);\n        System.out.println(\"base64-mac值为： \" + hmacBase64String);\n        boolean verifyMac_result = softSession.verifyMac(mechanism, jkey, srcData.getBytes(), hmac_result);\n        System.out.println(\"验证HMAC结果： \" + verifyMac_result);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于HMAC-SHA384算法的MAC代码",
        "input": "",
        "output": "public void mackWithHMAC_SHA384() {\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        //HMAC原文\n        String srcData = \"这是一段数据原文\";\n        // 创建密钥加密机制\n        Mechanism mechanism_key = new Mechanism(Mechanism.AES_KEY);\n        JKey jkey = softSession.generateKey(mechanism_key, 64);\n        // 创建HMAC加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.HMAC_SHA384);\n        byte[] hmac_result = softSession.mac(mechanism, jkey, srcData.getBytes());\n        String hmacBase64String = Base64.toBase64String(hmac_result);\n        System.out.println(\"base64-mac值为： \" + hmacBase64String);\n        boolean verifyMac_result = softSession.verifyMac(mechanism, jkey, srcData.getBytes(), hmac_result);\n        System.out.println(\"验证HMAC结果： \" + verifyMac_result);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于HMAC-SM3算法的MAC代码",
        "input": "",
        "output": "public void mackWithHMAC_SM3() {\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        //HMAC原文\n        String srcData = \"这是一段数据原文\";\n        // 创建密钥加密机制\n        Mechanism mechanism_key = new Mechanism(Mechanism.AES_KEY);\n        JKey jkey = softSession.generateKey(mechanism_key, 64);\n        // 创建HMAC加密机制\n        Mechanism mechanism = new Mechanism(Mechanism.HMAC_SM3);\n        byte[] hmac_result = softSession.mac(mechanism, jkey, srcData.getBytes());\n        String hmacBase64String = Base64.toBase64String(hmac_result);\n        System.out.println(\"base64-mac值为： \" + hmacBase64String);\n        boolean verifyMac_result = softSession.verifyMac(mechanism, jkey, srcData.getBytes(), hmac_result);\n        System.out.println(\"验证HMAC结果： \" + verifyMac_result);\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现 自签发RSA算法，密钥长度为2048的根证书",
        "input": "",
        "output": "public void generateRootCert() {\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    int keyLength = 2048;\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 生成根证书 密钥对\n        JKeyPair rootKeyPair = softSession.generateKeyPair(new Mechanism(Mechanism.RSA), keyLength);\n        System.out.println(\"root key public key : \" + Base64.encodeToString(rootKeyPair.getPublicKey().getKey()));\n        System.out.println(\"root key private key : \" + Base64.encodeToString(rootKeyPair.getPrivateKey().getKey()));\n        //保存根私钥\n        FileOutputStream fosKey = new FileOutputStream(\"./cert/rootprivatekey.pem\");\n        fosKey.write(rootKeyPair.getPrivateKey().getKey());\n        fosKey.flush();\n        fosKey.close();\n        //保存根公钥\n        FileOutputStream fosPubKey = new FileOutputStream(\"./cert/rootpublickey.pem\");\n        fosPubKey.write(rootKeyPair.getPublicKey().getKey());\n        fosPubKey.flush();\n        fosPubKey.close();\n        X509CertGenerator generator2 = new X509CertGenerator();\n        // 定义证书有效期\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n        Date notBefore = sdf.parse(\"2024-06-04\");\n        Date notAfter = sdf.parse(\"2044-06-04\");\n        // 定义证书主题\n        String subjectName = \"cn=172.16.32.146,o=jit,c=cn\";\n        // 证书颁发者 CA信息\n        generator2.setIssuer(subjectName);\n        // 证书主体 即证书持有者身份，如果是根证书，证书颁发者和证书主体是一样的\n        generator2.setSubject(subjectName);\n        // 证书序列号\n        generator2.setSerialNumber(new BigInteger(\"3D19AD85BE02AF281591\", 16));\n        // 证书有效期\n        generator2.setNotBefore(notBefore);\n        generator2.setNotAfter(notAfter);\n        // 证书签名算法，用于验签\n        generator2.setSignatureAlg(Mechanism.SHA256_RSA);\n        // 证书公钥\n        generator2.setPublicKey(rootKeyPair.getPublicKey());\n        Vector<Extension> extensions2 = new Vector<Extension>();\n        /*\n             * 是一个扩展字段，用于指示证书的类型以及证书主体是否有权限签发其他证书这个扩展是非常重要的，因为它可以用来区分证书颁发机构（CAs）的证书和终端实体（\n             * 如个人、服务器）的证书\n             * “Basic Constraints”扩展包含以下几个组成部分：\n             * CA（Certificate Authority）标志：此标志指示证书是否可以用作CA证书\n             * 如果设置为TRUE，证书持有者可以使用它来签发其他证书，这意味着它是一个CA证书\n             * 如果设置为FALSE或该标志不存在，则证书不用于签发其他证书，即它是一个终端实体证书\n             * pathLenConstraint：此选项仅在CA字段为TRUE时才有意义，它定义了证书链中下级CA证书的最大允许数量例如，如果设置为0，\n             * 则表示该CA证书只能用来直接签发终端实体证书，而不能签发其他CA证书如果没有设置这个限制，则CA可以签发任意数量的下级CA证书\n             */\n        BasicConstraintsExt bc = new BasicConstraintsExt(true);\n        bc.setCritical(true);\n        extensions2.add(bc);\n        // 密钥用法 确定公钥的用法\n        KeyUsageExt keyUsage = new KeyUsageExt();\n        keyUsage.setCritical(false);\n        // 允许公钥用于验证数字签名，这通常用于证实发送的数据是未被篡改的，并且是由持有相应私钥的实体签署的\n        keyUsage.addKeyUsage(KeyUsageExt.DIGITAL_SIGNATURE);\n        // 允许公钥用于验证签名，以防止发送方否认之前发送过的信息这通常用于具有法律或合同意义的场合\n        keyUsage.addKeyUsage(KeyUsageExt.NON_REPUDIATION);\n        // 允许公钥用于加密会话密钥，这样只有持有对应私钥的接收方才能解密这个会话密钥，并用其解密信息\n        keyUsage.addKeyUsage(KeyUsageExt.DATA_ENCIPHERMENT);\n        // 允许公钥直接用于加密数据，而不是加密会话密钥\n        keyUsage.addKeyUsage(KeyUsageExt.KEY_ENCIPHERMENT);\n        // 允许公钥用于签署其他证书，这意味着证书可以作为证书颁发机构（CA）使用只有CA证书才应该具有这个用途\n        keyUsage.addKeyUsage(KeyUsageExt.KEY_CERT_SIGN);\n        // 允许公钥用于签署证书吊销列表（CRLs），这些列表包含了被CA撤销的证书序列号\n        keyUsage.addKeyUsage(KeyUsageExt.CRL_SIGN);\n        extensions2.add(keyUsage);\n        // 主题备用名称\n        // extensions2.add(genAltName());\n        /*\n             * 主题密钥标识符（Subject Key Identifier， SKI）\n             * 用来唯一标识证书中的公钥的SKI通常是从公钥本身生成的一个散列值，它为证书链的构建和证书路径的验证提供了一种机制\n             * \n             * 这个扩展的主要目的是在有多个证书拥有相同主题名称的情况下，帮助唯一地识别这些证书中的公钥这在证书的续订和吊销过程中尤其重要，\n             * 以确保证书链中各个证书正确地链接到其对应的实体SKI扩展通常包含以下信息：\n             * \n             * keyIdentifier：这是证书主体的公钥的散列值，通常使用SHA-1或其他散列算法计算得出这个散列值作为证书的公钥的唯一标识符\n             * 通过使用SKI，可以在验证证书链时确保每个证书都准确地指向其上游的证书颁发机构（CA）这有助于简化证书链的处理，提高验证过程的效率\n             * \n             */\n        SubjectKeyIdentifierExt subjectKeyID2 = new SubjectKeyIdentifierExt(rootKeyPair.getPublicKey());\n        // 密钥标识符\n        subjectKeyID2.setCritical(false);\n        extensions2.add(subjectKeyID2);\n        /*\n             * 授权密钥标识符（Authority Key Identifier， AKI）\n             * 用来帮助唯一地标识证书颁发机构（CA）的公钥的AKI扩展对于构建证书链非常有用，因为它提供了一个链接到颁发证书的CA的标识符，\n             * 这有助于证书验证过程中的证书链验证\n             * \n             * “Authority Key Identifier”扩展通常包含以下信息：\n             * \n             * keyIdentifier：这是从CA的公钥中派生的一个唯一标识符它通常是CA公钥的一个散列值（例如，使用SHA-1算法），\n             * 这个散列值可以用来快速比较和确认CA证书的公钥\n             * \n             * authorityCertIssuer：这是一个可选字段，包含颁发CA证书的颁发者名称它是一个指向CA证书颁发者的链接，可以用来在证书链中回溯查找\n             * \n             * authorityCertSerialNumber：这也是一个可选字段，包含颁发CA证书的序列号与“keyIdentifier”一起，\n             * 这个字段提供了在证书库中查找CA证书所需的足够信息\n             * \n             * “Authority Key Identifier”扩展对于区分具有相同颁发者名称的不同CA证书特别有用当CA证书需要更新或替换时，\n             * 可以通过AKI来确保证书链中每个证书正确指向其特定的颁发证书\n             * \n             */\n        AuthorityKeyIdentifierExt auth = new AuthorityKeyIdentifierExt(rootKeyPair.getPublicKey());\n        // 密钥标识符\n        auth.setCritical(false);\n        extensions2.add(auth);\n        // 扩展赋值\n        generator2.setExtensiond(extensions2);\n        // 生成数字证书\n        X509Cert rootcert = new X509Cert(generator2.generateX509Cert(rootKeyPair.getPrivateKey(), softSession));\n        // 打印数字证书 base64字符串\n        System.out.println(\"user cert:\" + new String(Base64.encode(rootcert.getEncoded())));\n        // 生成cer 格式证书文件\n        String rootCertPath = \"./cert/root.cer\";\n        FileOutputStream fos = new FileOutputStream(rootCertPath);\n        fos.write(rootcert.getEncoded());\n        fos.flush();\n        fos.close();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现 解析证书",
        "input": "",
        "output": "public void parseCert() {\n    String certPath = \"./cert/root.cer\";\n    try {\n        byte[] certBytes = new byte[1024];\n        FileInputStream in = new FileInputStream(certPath);\n        in.read(certBytes);\n        in.close();\n        X509Cert rootCert = new X509Cert(certBytes);\n        System.out.println(\"证书版本：\" + rootCert.getVersion());\n        System.out.println(\"证书序列号：\" + rootCert.getStringSerialNumber());\n        System.out.println(\"证书颁发者：\" + rootCert.getIssuer());\n        System.out.println(\"证书主体：\" + rootCert.getSubject());\n        System.out.println(\"证书有效期：\" + rootCert.getNotBefore() + \"-\" + rootCert.getNotAfter());\n        System.out.println(\"证书签名算法：\" + rootCert.getSignatureAlgName());\n        System.out.println(\"证书公钥：\" + java.util.Base64.getEncoder().encodeToString(rootCert.getPublicKey().getKey()));\n        System.out.println(\"证书签名：\" + new String(Base64.encode(rootCert.getSignature())));\n        byte[] bytes = rootCert.getTBSCertificate();\n        ASN1InputStream aIn = new ASN1InputStream(bytes);\n        DERObject obj = aIn.readObject();\n        String str = obj.toString();\n        aIn.close();\n        System.out.println(\"证书内容：\" + str);\n    } catch (IOException | PKIException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，生成证书申请文件p10 基于rsa算法",
        "input": "",
        "output": "public void generateP10() {\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 初始化加密库\n    try {\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        PKCS10 p10Object = new PKCS10(softSession);\n        String signatureAlgorithm = Mechanism.SHA256_RSA;\n        String subject = \"cn=frank,c=cn,o=jit\";\n        JKeyPair keyPair = softSession.generateKeyPair(new Mechanism(Mechanism.RSA), 2048);\n        System.out.println(\"user private key: \" + Base64.encodeToString(keyPair.getPrivateKey().getKey()));\n        System.out.println(\"user public key:  \" + Base64.encodeToString(keyPair.getPublicKey().getKey()));\n        FileOutputStream userkeyOus = new FileOutputStream(\"./cert/userkey.pem\");\n        userkeyOus.write(keyPair.getPrivateKey().getKey());\n        userkeyOus.flush();\n        userkeyOus.close();\n        // 生成证书请求数据 base64编码\n        byte[] p10data = p10Object.generateCertificationRequestData_B64(signatureAlgorithm, subject, keyPair.getPublicKey(), null, keyPair.getPrivateKey());\n        if (p10Object != null) {\n            System.out.println(\"p10 申请成功\");\n        }\n        // 生成证书请求文件\n        String csrpath = \"./cert/certrequest.cer\";\n        FileOutputStream fos = new FileOutputStream(csrpath);\n        fos.write(p10data);\n        fos.flush();\n        fos.close();\n    } catch (PKIException | IOException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，解析证书请求文件p10",
        "input": "",
        "output": "public void parseP10() {\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 初始化加密库\n    try {\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 证书请求文件保存路径\n        String csrPath = \"./cert/certrequest.cer\";\n        FileInputStream fin = new FileInputStream(csrPath);\n        byte[] p10data = new byte[fin.available()];\n        fin.read(p10data);\n        fin.close();\n        // String p10Str =\n        // \"MIICcDCCAVgCAQAwKzEMMAoGA1UECgwDaml0MQswCQYDVQQGEwJjbjEOMAwGA1UEAwwFZnJhbmswggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCplFnQEQeLTkrMDXAi4RAah5nmgYUGc+gNpEpSls/mQFH3DHAAo8sY5V5Y3OJwz1VtmKIrplOBkAxtiQreR6vC+0SQF0JsquWwYM+1uZyli85hYMVLKU8Q2PTs5ACTFATxT/FSQI0f57t6m2HLVC06DytsbNUUwG5BkTRh2FnocmOo97VetOL2n9bJ0IJHn2/AgTaid0eFJtdQnXLc9OJjYPNrWQvHoiBcg4Gv+Fm5ocZLZ5zvvxGtodmvdcU5g0VQ1gk9aFgD4nRIi5A31q9vWrYG069wYmuIyFXDITvgLNcpFblwkp2KWd5tZj/x0C5cNoeEXk1k7pRJX8LLdqJXAgMBAAGgADANBgkqhkiG9w0BAQsFAAOCAQEAOhjy4bwx3KqB8SBAwa1NQ6ktE7KbiDt7ir1QwfEuCTAiuIF09Z/mCoHS7V18UeepqaprYSNzK/UQsHaG17EY7abQAV7uaSqh4RokKalQEXp/eKna20gn3QSEmBsnXyzonlP0fLZllRs+ZQLqbLtxSMphhDVxCeme8BPRnDEkFR8E1UyfuyYsACPD5S9V03c/THoJF6qd5bXO03t8Gx09CkkiSdgGndRAnvGBX+ywhcv0E7z57J+DlFLlA5oi7kHnDW7B9ejkVZ2dAzDowuJLV8pfa2rCVkhuHLpCzs2D1DsU/+X6E/omSeKvVEBeN93RCVpOViZ9eWvE94Szqq/mSQ==\";\n        PKCS10 p10 = new PKCS10(softSession);\n        // 解析证书请求文件\n        p10.load(p10data, \"true\");\n        System.out.println(\"p10 subject: \" + p10.getSubject());\n        System.out.println(\"public key type: \" + p10.getPubKey().getKeyType());\n        System.out.println(\"public key: \" + java.util.Base64.getEncoder().encodeToString(p10.getPubKey().getKey()));\n    } catch (PKIException e) {\n        e.printStackTrace();\n    } catch (FileNotFoundException e) {\n        e.printStackTrace();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的 签发rsa证书",
        "input": "",
        "output": "public void signCert() {\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 初始化加密库\n    try {\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 证书请求文件保存路径\n        String csrPath = \"./cert/certrequest.cer\";\n        FileInputStream fin = new FileInputStream(csrPath);\n        byte[] p10data = new byte[fin.available()];\n        fin.read(p10data);\n        fin.close();\n        PKCS10 p10 = new PKCS10(softSession);\n        // 解析证书请求文件\n        p10.load(p10data, \"true\");\n        String subjectName = p10.getSubject();\n        // 从p10文件中解析出来的证书公钥\n        JKey publicKey = p10.getPubKey();\n        // 根证私钥，用于签名证书信息 tbscertificate 可根据实际需要替换真实密钥\n        FileInputStream rootPriKeyFis = new FileInputStream(\"./cert/rootprivatekey.pem\");\n        byte[] rootPriKeyBytes = new byte[rootPriKeyFis.available()];\n        rootPriKeyFis.read(rootPriKeyBytes);\n        rootPriKeyFis.close();\n        JKey rootPrivateKey = new JKey(JKey.RSA_PRV_KEY, rootPriKeyBytes);\n        // 根证公钥，可根据实际需要替换真实密钥\n        FileInputStream rootPubKeyFis = new FileInputStream(\"./cert/rootpublickey.pem\");\n        byte[] rootPubKeyBytes = new byte[rootPubKeyFis.available()];\n        rootPubKeyFis.read(rootPubKeyBytes);\n        rootPubKeyFis.close();\n        JKey rootPublicKey = new JKey(JKey.RSA_PUB_KEY, rootPubKeyBytes);\n        X509CertGenerator generator2 = new X509CertGenerator();\n        // 定义证书有效期\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n        Date notBefore = sdf.parse(\"2024-06-04\");\n        Date notAfter = sdf.parse(\"2044-06-04\");\n        // 证书颁发者 CA信息\n        generator2.setIssuer(\"cn=172.16.32.146,o=jit,c=cn\");\n        // 证书主体 即证书持有者身份，如果是根证书，证书颁发者和证书主体是一样的\n        generator2.setSubject(subjectName);\n        // 证书序列号\n        generator2.setSerialNumber(new BigInteger(String.valueOf(System.currentTimeMillis()), 16));\n        // 证书有效期\n        generator2.setNotBefore(notBefore);\n        generator2.setNotAfter(notAfter);\n        // 证书签名算法，用于验签\n        generator2.setSignatureAlg(Mechanism.SHA256_RSA);\n        // 证书公钥\n        generator2.setPublicKey(publicKey);\n        Vector<Extension> extensions2 = new Vector<Extension>();\n        BasicConstraintsExt bc = new BasicConstraintsExt(false);\n        bc.setCritical(true);\n        extensions2.add(bc);\n        // 密钥用法 确定公钥的用法\n        KeyUsageExt keyUsage = new KeyUsageExt();\n        keyUsage.setCritical(false);\n        // 允许公钥用于验证数字签名，这通常用于证实发送的数据是未被篡改的，并且是由持有相应私钥的实体签署的\n        keyUsage.addKeyUsage(KeyUsageExt.DIGITAL_SIGNATURE);\n        // 允许公钥用于验证签名，以防止发送方否认之前发送过的信息这通常用于具有法律或合同意义的场合\n        keyUsage.addKeyUsage(KeyUsageExt.NON_REPUDIATION);\n        // 允许公钥用于加密会话密钥，这样只有持有对应私钥的接收方才能解密这个会话密钥，并用其解密信息\n        keyUsage.addKeyUsage(KeyUsageExt.DATA_ENCIPHERMENT);\n        // 允许公钥直接用于加密数据，而不是加密会话密钥\n        keyUsage.addKeyUsage(KeyUsageExt.KEY_ENCIPHERMENT);\n        extensions2.add(keyUsage);\n        SubjectKeyIdentifierExt subjectKeyID2 = new SubjectKeyIdentifierExt(publicKey);\n        // 密钥标识符\n        subjectKeyID2.setCritical(false);\n        extensions2.add(subjectKeyID2);\n        AuthorityKeyIdentifierExt auth = new AuthorityKeyIdentifierExt(rootPublicKey.getKey());\n        // 密钥标识符\n        auth.setCritical(false);\n        extensions2.add(auth);\n        // 扩展赋值\n        generator2.setExtensiond(extensions2);\n        // 生成数字证书\n        X509Cert usercert = new X509Cert(generator2.generateX509Cert(rootPrivateKey, softSession));\n        // 打印数字证书 base64字符串\n        System.out.println(\"user cert:\" + new String(Base64.encode(usercert.getEncoded())));\n        // 生成cer 格式证书文件\n        String rootCertPath = \"./cert/frank.cer\";\n        FileOutputStream fos = new FileOutputStream(rootCertPath);\n        fos.write(usercert.getEncoded());\n        fos.flush();\n        fos.close();\n    } catch (PKIException e) {\n        e.printStackTrace();\n    } catch (IOException e) {\n        e.printStackTrace();\n    } catch (ParseException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的 生成p7b证书链文件",
        "input": "",
        "output": "public void generateP7b() {\n    String rootCertPath = \"./cert/root.cer\";\n    String userCertPath = \"./cert/frank.cer\";\n    try {\n        byte[] rootcertBytes = new byte[1024];\n        FileInputStream in_rootcert = new FileInputStream(rootCertPath);\n        in_rootcert.read(rootcertBytes);\n        in_rootcert.close();\n        X509Cert rootCert = new X509Cert(rootcertBytes);\n        byte[] usercertBytes = new byte[2048];\n        FileInputStream in_usercert = new FileInputStream(userCertPath);\n        in_usercert.read(usercertBytes);\n        in_usercert.close();\n        X509Cert UserCert = new X509Cert(usercertBytes);\n        P7B p7b = new P7B();\n        // 生成p7b 证书链\n        String p7bPath = \"./cert/certchain.cer\";\n        byte[] p7bdata = p7b.generateP7bData_B64(new X509Cert[] { rootCert, UserCert });\n        FileOutputStream out = new FileOutputStream(p7bPath);\n        out.write(p7bdata);\n        out.flush();\n        out.close();\n    } catch (PKIException e) {\n        e.printStackTrace();\n    } catch (FileNotFoundException e) {\n        e.printStackTrace();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的 生成PFX格式证书文件",
        "input": "",
        "output": "public void generatePfx() {\n    // PKCS＃12或PFX格式是二进制格式，用于将服务器证书，任何中间证书和私钥存储在一个可加密文件中\n    try {\n        // 读取证书\n        String userCertPath = \"./cert/frank.cer\";\n        byte[] usercertBytes = new byte[2048];\n        FileInputStream in_usercert = new FileInputStream(userCertPath);\n        in_usercert.read(usercertBytes);\n        in_usercert.close();\n        X509Cert UserCert = new X509Cert(usercertBytes);\n        String pwd = \"111111\";\n        // 获取私钥  根据实际需要自定义填充私钥值\n        FileInputStream userPriKeyFis = new FileInputStream(\"./cert/userkey.pem\");\n        byte[] userPriKeyBytes = new byte[userPriKeyFis.available()];\n        userPriKeyFis.read(userPriKeyBytes);\n        userPriKeyFis.close();\n        JKey priJKey = new JKey(JKey.RSA_PRV_KEY, userPriKeyBytes);\n        PKCS12 p12 = new PKCS12();\n        byte[] p12byte = p12.generatePfxData(priJKey, UserCert, pwd.toCharArray());\n        System.out.println(\"user P12:\" + new String(Base64.encode(p12byte)));\n        //导出pfx 格式文件\n        String pfxPath = \"./cert/frank.pfx\";\n        FileOutputStream out = new FileOutputStream(pfxPath);\n        out.write(p12byte);\n        out.flush();\n        out.close();\n    } catch (PKIException e) {\n        e.printStackTrace();\n    } catch (FileNotFoundException e) {\n        e.printStackTrace();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现 自签发SM2算法根证书",
        "input": "",
        "output": "public void generateRootGMCert() {\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    //SM2 密钥长度为256\n    int keyLength = 256;\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 生成根证书 密钥对\n        JKeyPair rootKeyPair = softSession.generateKeyPair(new Mechanism(Mechanism.SM2), keyLength);\n        System.out.println(\"root key public key : \" + Base64.encodeToString(rootKeyPair.getPublicKey().getKey()));\n        System.out.println(\"root key private key : \" + Base64.encodeToString(rootKeyPair.getPrivateKey().getKey()));\n        //保存根私钥\n        FileOutputStream fosKey = new FileOutputStream(\"./certgm/rootprivatekey.pem\");\n        fosKey.write(rootKeyPair.getPrivateKey().getKey());\n        fosKey.flush();\n        fosKey.close();\n        //保存根公钥\n        FileOutputStream fosPubKey = new FileOutputStream(\"./certgm/rootpublickey.pem\");\n        fosPubKey.write(rootKeyPair.getPublicKey().getKey());\n        fosPubKey.flush();\n        fosPubKey.close();\n        X509CertGenerator generator2 = new X509CertGenerator();\n        // 定义证书有效期\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n        Date notBefore = sdf.parse(\"2024-06-04\");\n        Date notAfter = sdf.parse(\"2044-06-04\");\n        // 定义证书主题\n        String subjectName = \"cn=172.16.32.146,o=jit,c=cn\";\n        // 证书颁发者 CA信息\n        generator2.setIssuer(subjectName);\n        // 证书主体 即证书持有者身份，如果是根证书，证书颁发者和证书主体是一样的\n        generator2.setSubject(subjectName);\n        // 证书序列号\n        generator2.setSerialNumber(new BigInteger(\"3D19AD85BE02AF281591\", 16));\n        // 证书有效期\n        generator2.setNotBefore(notBefore);\n        generator2.setNotAfter(notAfter);\n        // 证书签名算法，用于验签\n        generator2.setSignatureAlg(Mechanism.SM3_SM2);\n        // 证书公钥\n        generator2.setPublicKey(rootKeyPair.getPublicKey());\n        Vector<Extension> extensions2 = new Vector<Extension>();\n        /*\n             * 是一个扩展字段，用于指示证书的类型以及证书主体是否有权限签发其他证书这个扩展是非常重要的，因为它可以用来区分证书颁发机构（CAs）的证书和终端实体（\n             * 如个人、服务器）的证书\n             * “Basic Constraints”扩展包含以下几个组成部分：\n             * CA（Certificate Authority）标志：此标志指示证书是否可以用作CA证书\n             * 如果设置为TRUE，证书持有者可以使用它来签发其他证书，这意味着它是一个CA证书\n             * 如果设置为FALSE或该标志不存在，则证书不用于签发其他证书，即它是一个终端实体证书\n             * pathLenConstraint：此选项仅在CA字段为TRUE时才有意义，它定义了证书链中下级CA证书的最大允许数量例如，如果设置为0，\n             * 则表示该CA证书只能用来直接签发终端实体证书，而不能签发其他CA证书如果没有设置这个限制，则CA可以签发任意数量的下级CA证书\n             */\n        BasicConstraintsExt bc = new BasicConstraintsExt(true);\n        bc.setCritical(true);\n        extensions2.add(bc);\n        // 密钥用法 确定公钥的用法\n        KeyUsageExt keyUsage = new KeyUsageExt();\n        keyUsage.setCritical(false);\n        // 允许公钥用于验证数字签名，这通常用于证实发送的数据是未被篡改的，并且是由持有相应私钥的实体签署的\n        keyUsage.addKeyUsage(KeyUsageExt.DIGITAL_SIGNATURE);\n        // 允许公钥用于验证签名，以防止发送方否认之前发送过的信息这通常用于具有法律或合同意义的场合\n        keyUsage.addKeyUsage(KeyUsageExt.NON_REPUDIATION);\n        // 允许公钥用于加密会话密钥，这样只有持有对应私钥的接收方才能解密这个会话密钥，并用其解密信息\n        keyUsage.addKeyUsage(KeyUsageExt.DATA_ENCIPHERMENT);\n        // 允许公钥直接用于加密数据，而不是加密会话密钥\n        keyUsage.addKeyUsage(KeyUsageExt.KEY_ENCIPHERMENT);\n        // 允许公钥用于签署其他证书，这意味着证书可以作为证书颁发机构（CA）使用只有CA证书才应该具有这个用途\n        keyUsage.addKeyUsage(KeyUsageExt.KEY_CERT_SIGN);\n        // 允许公钥用于签署证书吊销列表（CRLs），这些列表包含了被CA撤销的证书序列号\n        keyUsage.addKeyUsage(KeyUsageExt.CRL_SIGN);\n        extensions2.add(keyUsage);\n        // 主题备用名称\n        // extensions2.add(genAltName());\n        /*\n             * 主题密钥标识符（Subject Key Identifier， SKI）\n             * 用来唯一标识证书中的公钥的SKI通常是从公钥本身生成的一个散列值，它为证书链的构建和证书路径的验证提供了一种机制\n             * \n             * 这个扩展的主要目的是在有多个证书拥有相同主题名称的情况下，帮助唯一地识别这些证书中的公钥这在证书的续订和吊销过程中尤其重要，\n             * 以确保证书链中各个证书正确地链接到其对应的实体SKI扩展通常包含以下信息：\n             * \n             * keyIdentifier：这是证书主体的公钥的散列值，通常使用SHA-1或其他散列算法计算得出这个散列值作为证书的公钥的唯一标识符\n             * 通过使用SKI，可以在验证证书链时确保每个证书都准确地指向其上游的证书颁发机构（CA）这有助于简化证书链的处理，提高验证过程的效率\n             * \n             */\n        SubjectKeyIdentifierExt subjectKeyID2 = new SubjectKeyIdentifierExt(rootKeyPair.getPublicKey());\n        // 密钥标识符\n        subjectKeyID2.setCritical(false);\n        extensions2.add(subjectKeyID2);\n        /*\n             * 授权密钥标识符（Authority Key Identifier， AKI）\n             * 用来帮助唯一地标识证书颁发机构（CA）的公钥的AKI扩展对于构建证书链非常有用，因为它提供了一个链接到颁发证书的CA的标识符，\n             * 这有助于证书验证过程中的证书链验证\n             * \n             * “Authority Key Identifier”扩展通常包含以下信息：\n             * \n             * keyIdentifier：这是从CA的公钥中派生的一个唯一标识符它通常是CA公钥的一个散列值（例如，使用SHA-1算法），\n             * 这个散列值可以用来快速比较和确认CA证书的公钥\n             * \n             * authorityCertIssuer：这是一个可选字段，包含颁发CA证书的颁发者名称它是一个指向CA证书颁发者的链接，可以用来在证书链中回溯查找\n             * \n             * authorityCertSerialNumber：这也是一个可选字段，包含颁发CA证书的序列号与“keyIdentifier”一起，\n             * 这个字段提供了在证书库中查找CA证书所需的足够信息\n             * \n             * “Authority Key Identifier”扩展对于区分具有相同颁发者名称的不同CA证书特别有用当CA证书需要更新或替换时，\n             * 可以通过AKI来确保证书链中每个证书正确指向其特定的颁发证书\n             * \n             */\n        AuthorityKeyIdentifierExt auth = new AuthorityKeyIdentifierExt(rootKeyPair.getPublicKey());\n        // 密钥标识符\n        auth.setCritical(false);\n        extensions2.add(auth);\n        // 扩展赋值\n        generator2.setExtensiond(extensions2);\n        // 生成数字证书\n        X509Cert rootcert = new X509Cert(generator2.generateX509Cert(rootKeyPair.getPrivateKey(), softSession));\n        // 打印数字证书 base64字符串\n        System.out.println(\"root cert:\" + new String(Base64.encode(rootcert.getEncoded())));\n        // 生成cer 格式证书文件\n        String rootCertPath = \"./certgm/rootsm2.cer\";\n        FileOutputStream fos = new FileOutputStream(rootCertPath);\n        fos.write(rootcert.getEncoded());\n        fos.flush();\n        fos.close();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现 解析证书",
        "input": "",
        "output": "public void parseGMCert() {\n    String certPath = \"./certgm/rootsm2.cer\";\n    try {\n        byte[] certBytes = new byte[1024];\n        FileInputStream in = new FileInputStream(certPath);\n        in.read(certBytes);\n        in.close();\n        X509Cert rootCert = new X509Cert(certBytes);\n        System.out.println(\"证书版本：\" + rootCert.getVersion());\n        System.out.println(\"证书序列号：\" + rootCert.getStringSerialNumber());\n        System.out.println(\"证书颁发者：\" + rootCert.getIssuer());\n        System.out.println(\"证书主体：\" + rootCert.getSubject());\n        System.out.println(\"证书有效期：\" + rootCert.getNotBefore() + \"-\" + rootCert.getNotAfter());\n        System.out.println(\"证书签名算法：\" + rootCert.getSignatureAlgName());\n        System.out.println(\"证书公钥：\" + java.util.Base64.getEncoder().encodeToString(rootCert.getPublicKey().getKey()));\n        System.out.println(\"证书签名：\" + new String(Base64.encode(rootCert.getSignature())));\n        byte[] bytes = rootCert.getTBSCertificate();\n        ASN1InputStream aIn = new ASN1InputStream(bytes);\n        DERObject obj = aIn.readObject();\n        String str = obj.toString();\n        aIn.close();\n        System.out.println(\"证书内容：\" + str);\n    } catch (IOException | PKIException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，生成证书申请文件p10 基于sm2算法",
        "input": "",
        "output": "public void generateGMP10() {\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 初始化加密库\n    try {\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        PKCS10 p10Object = new PKCS10(softSession);\n        String signatureAlgorithm = Mechanism.SM3_SM2;\n        String subject = \"cn=franksm2,c=cn,o=jit\";\n        JKeyPair keyPair = softSession.generateKeyPair(new Mechanism(Mechanism.SM2), 256);\n        System.out.println(\"user private key: \" + Base64.encodeToString(keyPair.getPrivateKey().getKey()));\n        System.out.println(\"user public key:  \" + Base64.encodeToString(keyPair.getPublicKey().getKey()));\n        FileOutputStream userkeyOus = new FileOutputStream(\"./certgm/userkey.pem\");\n        userkeyOus.write(keyPair.getPrivateKey().getKey());\n        userkeyOus.flush();\n        userkeyOus.close();\n        // 生成证书请求数据 base64编码\n        byte[] p10data = p10Object.generateCertificationRequestData_B64(signatureAlgorithm, subject, keyPair.getPublicKey(), null, keyPair.getPrivateKey());\n        if (p10Object != null) {\n            System.out.println(\"p10 申请成功\");\n        }\n        // 生成证书请求文件\n        String csrpath = \"./certgm/certrequestsm2.cer\";\n        FileOutputStream fos = new FileOutputStream(csrpath);\n        fos.write(p10data);\n        fos.flush();\n        fos.close();\n    } catch (PKIException | IOException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，解析证书请求文件p10 SM2算法",
        "input": "",
        "output": "public void parseGMP10() {\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 初始化加密库\n    try {\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 证书请求文件保存路径\n        String csrPath = \"./certgm/certrequestsm2.cer\";\n        FileInputStream fin = new FileInputStream(csrPath);\n        byte[] p10data = new byte[fin.available()];\n        fin.read(p10data);\n        fin.close();\n        // String p10Str =\n        // \"MIICcDCCAVgCAQAwKzEMMAoGA1UECgwDaml0MQswCQYDVQQGEwJjbjEOMAwGA1UEAwwFZnJhbmswggEiMA0GCSqGSIb3DQEBAQUAA4IBDwAwggEKAoIBAQCplFnQEQeLTkrMDXAi4RAah5nmgYUGc+gNpEpSls/mQFH3DHAAo8sY5V5Y3OJwz1VtmKIrplOBkAxtiQreR6vC+0SQF0JsquWwYM+1uZyli85hYMVLKU8Q2PTs5ACTFATxT/FSQI0f57t6m2HLVC06DytsbNUUwG5BkTRh2FnocmOo97VetOL2n9bJ0IJHn2/AgTaid0eFJtdQnXLc9OJjYPNrWQvHoiBcg4Gv+Fm5ocZLZ5zvvxGtodmvdcU5g0VQ1gk9aFgD4nRIi5A31q9vWrYG069wYmuIyFXDITvgLNcpFblwkp2KWd5tZj/x0C5cNoeEXk1k7pRJX8LLdqJXAgMBAAGgADANBgkqhkiG9w0BAQsFAAOCAQEAOhjy4bwx3KqB8SBAwa1NQ6ktE7KbiDt7ir1QwfEuCTAiuIF09Z/mCoHS7V18UeepqaprYSNzK/UQsHaG17EY7abQAV7uaSqh4RokKalQEXp/eKna20gn3QSEmBsnXyzonlP0fLZllRs+ZQLqbLtxSMphhDVxCeme8BPRnDEkFR8E1UyfuyYsACPD5S9V03c/THoJF6qd5bXO03t8Gx09CkkiSdgGndRAnvGBX+ywhcv0E7z57J+DlFLlA5oi7kHnDW7B9ejkVZ2dAzDowuJLV8pfa2rCVkhuHLpCzs2D1DsU/+X6E/omSeKvVEBeN93RCVpOViZ9eWvE94Szqq/mSQ==\";\n        PKCS10 p10 = new PKCS10(softSession);\n        // 解析证书请求文件\n        p10.load(p10data, \"true\");\n        System.out.println(\"p10 subject: \" + p10.getSubject());\n        System.out.println(\"public key type: \" + p10.getPubKey().getKeyType());\n        System.out.println(\"public key: \" + java.util.Base64.getEncoder().encodeToString(p10.getPubKey().getKey()));\n    } catch (PKIException e) {\n        e.printStackTrace();\n    } catch (FileNotFoundException e) {\n        e.printStackTrace();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的 签发SM2证书",
        "input": "",
        "output": "/public void signGMCert() throws Exception {\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 初始化加密库\n    try {\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 证书请求文件保存路径\n        String csrPath = \"./certgm/certrequestsm2.cer\";\n        FileInputStream fin = new FileInputStream(csrPath);\n        byte[] p10data = new byte[fin.available()];\n        fin.read(p10data);\n        fin.close();\n        PKCS10 p10 = new PKCS10(softSession);\n        // 解析证书请求文件\n        p10.load(p10data, \"true\");\n        String subjectName = p10.getSubject();\n        // 从p10文件中解析出来的证书公钥\n        JKey publicKey = p10.getPubKey();\n        // 根证私钥，用于签名证书信息 tbscertificate 可根据实际需要替换真实密钥\n        FileInputStream rootPriKeyFis = new FileInputStream(\"./certgm/rootprivatekey.pem\");\n        byte[] rootPriKeyBytes = new byte[rootPriKeyFis.available()];\n        rootPriKeyFis.read(rootPriKeyBytes);\n        rootPriKeyFis.close();\n        JKey rootPrivateKey = new JKey(JKey.RSA_PRV_KEY, rootPriKeyBytes);\n        // 根证公钥，可根据实际需要替换真实密钥\n        FileInputStream rootPubKeyFis = new FileInputStream(\"./certgm/rootpublickey.pem\");\n        byte[] rootPubKeyBytes = new byte[rootPubKeyFis.available()];\n        rootPubKeyFis.read(rootPubKeyBytes);\n        rootPubKeyFis.close();\n        JKey rootPublicKey = new JKey(JKey.RSA_PUB_KEY, rootPubKeyBytes);\n        X509CertGenerator generator2 = new X509CertGenerator();\n        // 定义证书有效期\n        SimpleDateFormat sdf = new SimpleDateFormat(\"yyyy-MM-dd\");\n        Date notBefore = sdf.parse(\"2024-06-04\");\n        Date notAfter = sdf.parse(\"2044-06-04\");\n        // 证书颁发者 CA信息\n        generator2.setIssuer(\"cn=172.16.32.146,o=jit,c=cn\");\n        // 证书主体 即证书持有者身份，如果是根证书，证书颁发者和证书主体是一样的\n        generator2.setSubject(subjectName);\n        // 证书序列号\n        generator2.setSerialNumber(new BigInteger(String.valueOf(System.currentTimeMillis()), 16));\n        // 证书有效期\n        generator2.setNotBefore(notBefore);\n        generator2.setNotAfter(notAfter);\n        // 证书签名算法，用于验签\n        generator2.setSignatureAlg(Mechanism.SM3_SM2);\n        // 证书公钥\n        generator2.setPublicKey(publicKey);\n        Vector<Extension> extensions2 = new Vector<Extension>();\n        BasicConstraintsExt bc = new BasicConstraintsExt(false);\n        bc.setCritical(true);\n        extensions2.add(bc);\n        // 密钥用法 确定公钥的用法\n        KeyUsageExt keyUsage = new KeyUsageExt();\n        keyUsage.setCritical(false);\n        // 允许公钥用于验证数字签名，这通常用于证实发送的数据是未被篡改的，并且是由持有相应私钥的实体签署的\n        keyUsage.addKeyUsage(KeyUsageExt.DIGITAL_SIGNATURE);\n        // 允许公钥用于验证签名，以防止发送方否认之前发送过的信息这通常用于具有法律或合同意义的场合\n        keyUsage.addKeyUsage(KeyUsageExt.NON_REPUDIATION);\n        // 允许公钥用于加密会话密钥，这样只有持有对应私钥的接收方才能解密这个会话密钥，并用其解密信息\n        keyUsage.addKeyUsage(KeyUsageExt.DATA_ENCIPHERMENT);\n        // 允许公钥直接用于加密数据，而不是加密会话密钥\n        keyUsage.addKeyUsage(KeyUsageExt.KEY_ENCIPHERMENT);\n        extensions2.add(keyUsage);\n        SubjectKeyIdentifierExt subjectKeyID2 = new SubjectKeyIdentifierExt(publicKey);\n        // 密钥标识符\n        subjectKeyID2.setCritical(false);\n        extensions2.add(subjectKeyID2);\n        AuthorityKeyIdentifierExt auth = new AuthorityKeyIdentifierExt(rootPublicKey.getKey());\n        // 密钥标识符\n        auth.setCritical(false);\n        extensions2.add(auth);\n        // 扩展赋值\n        generator2.setExtensiond(extensions2);\n        // 生成数字证书\n        X509Cert usercert = new X509Cert(generator2.generateX509Cert(rootPrivateKey, softSession));\n        // 打印数字证书 base64字符串\n        System.out.println(\"user cert:\" + new String(Base64.encode(usercert.getEncoded())));\n        // 生成cer 格式证书文件\n        String rootCertPath = \"./certgm/franksm2.cer\";\n        FileOutputStream fos = new FileOutputStream(rootCertPath);\n        fos.write(usercert.getEncoded());\n        fos.flush();\n        fos.close();\n    } catch (PKIException e) {\n        e.printStackTrace();\n    } catch (IOException e) {\n        e.printStackTrace();\n    } catch (ParseException e) {\n        e.printStackTrace();\n    } catch (ClassCastException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的 生成p7b证书链文件 SM2算法",
        "input": "",
        "output": "public void generateGMP7b() {\n    String rootCertPath = \"./certgm/rootsm2.cer\";\n    String userCertPath = \"./certgm/franksm2.cer\";\n    try {\n        byte[] rootcertBytes = new byte[1024];\n        FileInputStream in_rootcert = new FileInputStream(rootCertPath);\n        in_rootcert.read(rootcertBytes);\n        in_rootcert.close();\n        X509Cert rootCert = new X509Cert(rootcertBytes);\n        byte[] usercertBytes = new byte[2048];\n        FileInputStream in_usercert = new FileInputStream(userCertPath);\n        in_usercert.read(usercertBytes);\n        in_usercert.close();\n        X509Cert UserCert = new X509Cert(usercertBytes);\n        P7B p7b = new P7B();\n        // 生成p7b 证书链\n        String p7bPath = \"./certgm/certchainsm2.cer\";\n        byte[] p7bdata = p7b.generateP7bData_B64(new X509Cert[] { rootCert, UserCert });\n        FileOutputStream out = new FileOutputStream(p7bPath);\n        out.write(p7bdata);\n        out.flush();\n        out.close();\n    } catch (PKIException e) {\n        e.printStackTrace();\n    } catch (FileNotFoundException e) {\n        e.printStackTrace();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的 软实现 编写P7数字信封的代码，基于RSA算法",
        "input": "",
        "output": "public void envelopedDataByRsa() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // pfx证书路径\n    String certFilePath = \"./cert/frank.pfx\";\n    // pfx证书密码\n    String p12Pwd = \"111111\";\n    // 消息原文\n    byte[] srcContent = \"Hello World\".getBytes();\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建对称密钥\n        Mechanism mechanismKey = new Mechanism(Mechanism.DES3_KEY);\n        // 加密原文的对称密钥\n        JKey keySrc = softSession.generateKey(mechanismKey, 128);\n        // 对称加密机制\n        Mechanism mechanismSrc = new Mechanism(Mechanism.DES3_ECB);\n        CBCParam iv = new CBCParam();\n        // 算法要求向量内容\n        iv.setIv(\"12345678\".getBytes());\n        mechanismSrc.setParam(iv);\n        // 读取P12证书 需要使用证书中的公钥对对称密钥进行加密\n        X509Cert[] certs = new X509Cert[1];\n        PKCS12 p12 = new PKCS12();\n        p12.reset();\n        p12.load(certFilePath);\n        p12.decrypt(p12Pwd.toCharArray());\n        certs[0] = p12.getCertificate();\n        // 创建非对称加密机制\n        Mechanism[] envMechs = { new Mechanism(Mechanism.RSA_PKCS) };\n        P7Param param = new P7Param();\n        // 设置P7 参数\n        param.SetEnvParam(keySrc, mechanismSrc, certs, envMechs);\n        // 创建PKCS7 实例\n        PKCS7 p7 = new PKCS7(softSession);\n        byte[] p7_data = p7.genP7_Env(srcContent, param);\n        String p7envfile = \"./p7/p7.env\";\n        FileOutputStream fos = new FileOutputStream(p7envfile);\n        fos.write(p7_data);\n        fos.flush();\n        fos.close();\n        System.out.println(\"gen p7 envelope success...\");\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的 软实现 编写P7数字信封的代码，基于国密算法SM4 SM2",
        "input": "",
        "output": "public void envelopedDataByGM() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // cer证书路径\n    String certFilePath = \"./certgm/franksm2.cer\";\n    // 消息原文\n    byte[] srcContent = \"Hello World\".getBytes();\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建对称密钥\n        Mechanism mechanismKey = new Mechanism(Mechanism.SM4);\n        // 加密原文的对称密钥\n        JKey keySrc = softSession.generateKey(mechanismKey, 24);\n        // 对称加密机制\n        Mechanism mechanismSrc = new Mechanism(Mechanism.SM4_CBC);\n        CBCParam iv = new CBCParam();\n        // 算法要求向量内容\n        iv.setIv(\"1234567812345678\".getBytes());\n        mechanismSrc.setParam(iv);\n        // 读取P12证书 需要使用证书中的公钥对对称密钥进行加密\n        X509Cert[] certs = new X509Cert[1];\n        byte[] usercertBytes = new byte[2048];\n        FileInputStream in_usercert = new FileInputStream(certFilePath);\n        in_usercert.read(usercertBytes);\n        in_usercert.close();\n        certs[0] = new X509Cert(usercertBytes);\n        // 创建非对称加密机制\n        Mechanism[] envMechs = { new Mechanism(Mechanism.SM2_RAW) };\n        P7Param param = new P7Param();\n        // 设置P7 参数\n        param.SetEnvParam(keySrc, mechanismSrc, certs, envMechs);\n        // 创建PKCS7 实例\n        PKCS7 p7 = new PKCS7(softSession);\n        p7.setIsSMP7(true);\n        byte[] p7_data = p7.genP7_Env(srcContent, param);\n        String p7envfile = \"./p7gm/p7.env\";\n        FileOutputStream fos = new FileOutputStream(p7envfile);\n        fos.write(p7_data);\n        fos.flush();\n        fos.close();\n        System.out.println(\"gen gm p7 envelope success...\");\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的 软实现 编写解密P7数字信封的代码，基于RSA算法",
        "input": "",
        "output": "public void parseAndVeriyP7ByRsa() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    String p7envFilePath = \"./p7/p7.env\";\n    String p12FilePath = \"./cert/frank.pfx\";\n    String p12Pwd = \"111111\";\n    PKCS7 p7 = null;\n    PKCS12 p12 = null;\n    // 解密原文\n    byte[] src;\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        p7 = new PKCS7(softSession);\n        // 读取P7文件\n        int p7Type = p7.load(p7envFilePath);\n        FileInputStream fin = new FileInputStream(p12FilePath);\n        byte[] data = new byte[fin.available()];\n        fin.read(data);\n        fin.close();\n        if (p7Type == PKCS7.PKCS7_CONTENT_TYPE_ENVELOPEDDATA) {\n            // 加载P12 证书获取私钥\n            p12 = new PKCS12();\n            p12.reset();\n            p12.load(p12FilePath);\n            p12.decrypt(p12Pwd.toCharArray());\n            p7recCertKey[] recs = new p7recCertKey[1];\n            recs[0] = new p7recCertKey(p12.getPrivateKey(), p12.getCertificate());\n            // 验证P7数字信封 解密原文\n            src = p7.verifyP7Env(recs, null);\n            if (src != null && src.length > 0) {\n                System.out.println(\"base64decode:\" + new String(src));\n            } else {\n                System.out.println(\"verify env failed...\");\n            }\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的 软实现 编写解密基于国密算法的P7数字信封的代码",
        "input": "",
        "output": "public void parseAndVeriyP7ByGM() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    String p7envFilePath = \"./p7gm/p7.env\";\n    String certfilePath = \"./certgm/franksm2.cer\";\n    String privateKeyPath = \"./certgm/userkey.pem\";\n    PKCS7 p7 = null;\n    // 解密原文\n    byte[] src;\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        p7 = new PKCS7(softSession);\n        // 读取P7文件\n        int p7Type = p7.load(p7envFilePath);\n        FileInputStream fin = new FileInputStream(certfilePath);\n        byte[] data = new byte[fin.available()];\n        fin.read(data);\n        fin.close();\n        if (p7Type == PKCS7.PKCS7_CONTENT_TYPE_ENVELOPEDDATA) {\n            // 加载证书\n            X509Cert cert = new X509Cert(data);\n            // 读取私钥\n            byte[] privateKeyBytes = new byte[2048];\n            FileInputStream in_privatekey = new FileInputStream(privateKeyPath);\n            in_privatekey.read(privateKeyBytes);\n            in_privatekey.close();\n            JKey privateKey = new JKey(JKey.SM2_PRV_KEY, privateKeyBytes);\n            p7recCertKey[] recs = new p7recCertKey[1];\n            recs[0] = new p7recCertKey(privateKey, cert);\n            // 验证P7数字信封 解密原文\n            src = p7.verifyP7Env(recs, null);\n            if (src != null && src.length > 0) {\n                System.out.println(\"base64decode:\" + new String(src));\n            } else {\n                System.out.println(\"verify env failed...\");\n            }\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的 软实现 编写P7数字签名的代码，基于RSA算法",
        "input": "",
        "output": "public void signP7ByRsa() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // pfx证书路径\n    String certFilePath = \"./cert/frank.pfx\";\n    // pfx证书密码\n    String p12Pwd = \"111111\";\n    // 消息原文\n    byte[] srcContent = \"Hello World\".getBytes();\n    String p7signfilePath = \"./p7/p7.rsapss.sign\";\n    PKCS7 p7 = null;\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 读取P12证书 需要使用证书中的私钥对消息进行签名\n        X509Cert[] certs = new X509Cert[1];\n        PKCS12 p12 = new PKCS12();\n        p12.reset();\n        p12.load(certFilePath);\n        p12.decrypt(p12Pwd.toCharArray());\n        certs[0] = p12.getCertificate();\n        // 创建签名加密机制，使用SHA256摘要，RSA_PSS 填充加密算法\n        Mechanism signMech = new Mechanism(Mechanism.SHA256_RSA_PSS);\n        // P7Param[] params = new P7Param[2];\n        P7Param[] params = new P7Param[1];\n        params[0] = new P7Param();\n        params[0].SetSignParam(p12.getPrivateKey(), signMech, certs, null, null, null);\n        p7 = new PKCS7(softSession);\n        byte[] p7_data = p7.genP7_Sign(srcContent, params, true);\n        FileOutputStream fos = new FileOutputStream(p7signfilePath);\n        fos.write(p7_data);\n        fos.flush();\n        fos.close();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的 软实现 编写基于国密算法P7数字签名的代码，SM3_SM2",
        "input": "",
        "output": "public void signP7ByGM() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 证书路径\n    String certFilePath = \"./certgm/franksm2.cer\";\n    // 私钥路径\n    String privateKeyPath = \"./certgm/userkey.pem\";\n    // 消息原文\n    byte[] srcContent = \"Hello World GM\".getBytes();\n    String p7signfilePath = \"./p7gm/p7.rsapss.sign\";\n    PKCS7 p7 = null;\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 读取证书\n        X509Cert[] certs = new X509Cert[1];\n        FileInputStream fin = new FileInputStream(certFilePath);\n        byte[] data = new byte[fin.available()];\n        fin.read(data);\n        fin.close();\n        certs[0] = new X509Cert(data);\n        // 读取私钥\n        byte[] privateKeyBytes = new byte[2048];\n        FileInputStream in_privatekey = new FileInputStream(privateKeyPath);\n        in_privatekey.read(privateKeyBytes);\n        in_privatekey.close();\n        JKey privateKey = new JKey(JKey.SM2_PRV_KEY, privateKeyBytes);\n        // 创建签名加密机制，使用SM3摘要，SM2 填充加密算法\n        Mechanism signMech = new Mechanism(Mechanism.SM3_SM2);\n        P7Param[] params = new P7Param[1];\n        params[0] = new P7Param();\n        params[0].SetSignParam(privateKey, signMech, certs, null, null, null);\n        p7 = new PKCS7(softSession);\n        p7.setIsSMP7(true);\n        byte[] p7_data = p7.genP7_Sign(srcContent, params, true);\n        FileOutputStream fos = new FileOutputStream(p7signfilePath);\n        fos.write(p7_data);\n        fos.flush();\n        fos.close();\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的 软实现 编写验签P7数字签名的代码，基于RSA算法",
        "input": "",
        "output": "public void verifyP7SignByRsa() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    String p7signFilePath = \"./p7/p7.rsapss.sign\";\n    PKCS7 p7 = null;\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        p7 = new PKCS7(softSession);\n        // 读取P7文件\n        int p7Type = p7.load(p7signFilePath);\n        P7Param param = p7.GetP7Cnt();\n        if (p7Type == PKCS7.PKCS7_CONTENT_TYPE_SIGNEDDATA) {\n            // 验证P7数字签名\n            boolean rv = p7.verifyP7Sign(null, null);\n            if (rv)\n                System.out.println(\"verify sign data success...\");\n            else\n                System.out.println(\"verify sign data failed...\");\n            byte[] data = param.GetSource();\n            if (null != data)\n                System.out.println(\"Source is:\" + new String(data));\n            else\n                System.out.println(\"There is no source in the p7...\");\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的 软实现 编写验签基于国密算法的P7数字签名的代码，",
        "input": "",
        "output": "public void verifyP7SignByGM() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    String p7signFilePath = \"./p7gm/p7.rsapss.sign\";\n    PKCS7 p7 = null;\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        p7 = new PKCS7(softSession);\n        // 读取P7文件\n        int p7Type = p7.load(p7signFilePath);\n        if (p7Type == PKCS7.PKCS7_CONTENT_TYPE_SIGNEDDATA) {\n            P7Param param = p7.GetP7Cnt();\n            // 验证P7数字签名\n            boolean rv = p7.verifyP7Sign(null, null);\n            if (rv)\n                System.out.println(\"verify sign data success...\");\n            else\n                System.out.println(\"verify sign data failed...\");\n            byte[] data = param.GetSource();\n            if (null != data)\n                System.out.println(\"Source is:\" + new String(data));\n            else\n                System.out.println(\"There is no source in the p7...\");\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写生成签名数字信封的代码，基于RSA算法",
        "input": "",
        "output": "public void signedAndEnvelopedDataByRsa() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // pfx证书路径 发送者证书\n    String certFilePath = \"./cert/frank.pfx\";\n    // 接收者 证书路径\n    String receiveFilePath = \"./cert/mike.cer\";\n    // pfx证书密码\n    String p12Pwd = \"111111\";\n    // 消息原文\n    byte[] srcContent = \"Hello World\".getBytes();\n    // 定义P7\n    PKCS7 p7 = null;\n    // p7 签名数字信封存储路径\n    String p7signenvfile = \"./p7/p7.signenv\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建对称密钥\n        Mechanism mechanismKey = new Mechanism(Mechanism.DES3_KEY);\n        // 加密原文的对称密钥\n        JKey keySrc = softSession.generateKey(mechanismKey, 128);\n        // 对称加密机制\n        Mechanism mechanismSrc = new Mechanism(Mechanism.DES3_CBC);\n        // 定义随机向量，也可以自定义\n        byte[] iv = softSession.generateRandom(new Mechanism(Mechanism.RANDOM), 8);\n        // 定义加密机制\n        CBCParam cbcParam = new CBCParam();\n        cbcParam.setIv(iv);\n        mechanismSrc.setParam(cbcParam);\n        // 读取发送者P12证书 需要使用私钥做签名\n        PKCS12 p12 = new PKCS12();\n        p12.reset();\n        p12.load(certFilePath);\n        p12.decrypt(p12Pwd.toCharArray());\n        // 读取接收者证书\n        byte[] receiveCertByte = new byte[2048];\n        FileInputStream in_usercert = new FileInputStream(receiveFilePath);\n        in_usercert.read(receiveCertByte);\n        in_usercert.close();\n        X509Cert receiveCert = new X509Cert(receiveCertByte);\n        X509Cert[] certs = new X509Cert[1];\n        certs[0] = receiveCert;\n        // 签名加密机制 用于原文签名\n        Mechanism signMech = new Mechanism(Mechanism.SHA1_RSA);\n        // 非对称加密机制，使用接收者公钥加密 对称密钥\n        Mechanism envMech = new Mechanism(Mechanism.RSA_PKCS);\n        P7Param[] params = new P7Param[1];\n        params[0] = new P7Param();\n        // 参数说明： 发送者私钥、签名算法、接收者证书、对称加密密钥、对称机密机制、非对称加密机制\n        params[0].SetSignEnvParam(p12.getPrivateKey(), signMech, certs, null, null, null, keySrc, mechanismSrc, envMech);\n        // 实例PKCS7\n        p7 = new PKCS7(softSession);\n        byte[] p7_data = p7.genP7_SignEnv(srcContent, params);\n        // 签名数字信封写入文件\n        FileOutputStream out = new FileOutputStream(p7signenvfile);\n        out.write(p7_data);\n        out.flush();\n        out.close();\n    } catch (PKIException e) {\n        e.printStackTrace();\n    } catch (FileNotFoundException e) {\n        e.printStackTrace();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的软实现，编写基于国密算法生成签名数字信封的代码，基于SM2、SM3、SM4",
        "input": "",
        "output": "/public void signedAndEnvelopedDataByGM() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // 发送者私钥路径\n    String sendPrivateKeyFilePath = \"./certgm/userkey.pem\";\n    // 接收者 证书路径\n    String receiveFilePath = \"./certgm/mikesm2.cer\";\n    // 消息原文\n    byte[] srcContent = \"Hello World GM\".getBytes();\n    // 定义P7\n    PKCS7 p7 = null;\n    // p7 签名数字信封存储路径\n    String p7signenvfile = \"./p7gm/p7.signenv\";\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        // 创建对称密钥\n        Mechanism mechanismKey = new Mechanism(Mechanism.SM4);\n        // 加密原文的对称密钥\n        JKey keySrc = softSession.generateKey(mechanismKey, 24);\n        // 对称加密机制\n        Mechanism mechanismSrc = new Mechanism(Mechanism.SM4_ECB);\n        // 读取发送者私钥，用发送者私钥做签名\n        FileInputStream in_privatekey = new FileInputStream(sendPrivateKeyFilePath);\n        byte[] privateKeyBytes = new byte[2048];\n        in_privatekey.read(privateKeyBytes);\n        in_privatekey.close();\n        JKey privateKey = new JKey(JKey.SM2_PRV_KEY, privateKeyBytes);\n        // 读取接收者证书\n        byte[] receiveCertByte = new byte[2048];\n        FileInputStream in_usercert = new FileInputStream(receiveFilePath);\n        in_usercert.read(receiveCertByte);\n        in_usercert.close();\n        X509Cert receiveCert = new X509Cert(receiveCertByte);\n        X509Cert[] certs = new X509Cert[1];\n        certs[0] = receiveCert;\n        // 签名加密机制 用于原文签名\n        Mechanism signMech = new Mechanism(Mechanism.SM3_SM2);\n        // 非对称加密机制，使用接收者公钥加密 对称密钥\n        Mechanism envMech = new Mechanism(Mechanism.SM2_RAW);\n        P7Param[] params = new P7Param[1];\n        params[0] = new P7Param();\n        // 参数说明： 发送者私钥、签名算法、接收者证书、对称加密密钥、对称机密机制、非对称加密机制\n        params[0].SetSignEnvParam(privateKey, signMech, certs, null, null, null, keySrc, mechanismSrc, envMech);\n        // 实例PKCS7\n        p7 = new PKCS7(softSession);\n        p7.setIsSMP7(true);\n        byte[] p7_data = p7.genP7_SignEnv(srcContent, params);\n        // 签名数字信封写入文件\n        FileOutputStream out = new FileOutputStream(p7signenvfile);\n        out.write(p7_data);\n        out.flush();\n        out.close();\n    } catch (PKIException e) {\n        e.printStackTrace();\n    } catch (FileNotFoundException e) {\n        e.printStackTrace();\n    } catch (IOException e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的 软实现，编写解密p7签名数字信封的代码，基于RSA算法",
        "input": "",
        "output": "public void parseAndVeriySignP7RSa() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // p7签名数字信封路径\n    String p7signenvFilePath = \"./p7/p7.signenv\";\n    // 接收者证书路径\n    String receiveCertPath = \"./cert/mike.pfx\";\n    String p12Pwd = \"111111\";\n    PKCS7 p7 = null;\n    PKCS12 p12 = null;\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        p7 = new PKCS7(softSession);\n        // 读取P7文件\n        int p7Type = p7.load(p7signenvFilePath);\n        // 读取接收者证书 获取私钥\n        p12 = new PKCS12();\n        p12.reset();\n        p12.load(receiveCertPath);\n        p12.decrypt(p12Pwd.toCharArray());\n        p7recCertKey[] recs1 = new p7recCertKey[1];\n        // 设置接收者私钥和接收者证书\n        recs1[0] = new p7recCertKey(p12.getPrivateKey(), p12.getCertificate());\n        // 验证P7数字信封 解密原文\n        byte[] src = p7.verifyP7Env(recs1, null);\n        if (src != null && src.length > 0) {\n            System.out.println(\"验签解密成功..............\");\n            System.out.println(\"原文为： \" + new String(src, StandardCharsets.UTF_8));\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    },
    {
        "instruction": "请使用PKITool的 软实现，编写解密基于国密算法的p7签名数字信封的代码",
        "input": "",
        "output": "public void parseAndVeriySignP7GM() {\n    // 创建JCrypto实例\n    JCrypto crypto = JCrypto.getInstance();\n    Session softSession = null;\n    // p7签名数字信封路径\n    String p7signenvFilePath = \"./p7gm/p7.signenv\";\n    // 接收者证书路径\n    String receiveCertPath = \"./certgm/mikesm2.cer\";\n    // 接收者私钥路径\n    String receivePrivateKeyPath = \"./certgm/userkeymike.pem\";\n    PKCS7 p7 = null;\n    try {\n        // 初始化加密库\n        crypto.initialize(JCrypto.JSOFT_LIB, null);\n        // 获取会话\n        softSession = crypto.openSession(JCrypto.JSOFT_LIB);\n        p7 = new PKCS7(softSession);\n        // 读取P7文件\n        int p7Type = p7.load(p7signenvFilePath);\n        // 读取接收者证书\n        byte[] receiveCertByte = new byte[2048];\n        FileInputStream in_usercert = new FileInputStream(receiveCertPath);\n        in_usercert.read(receiveCertByte);\n        in_usercert.close();\n        X509Cert receiveCert = new X509Cert(receiveCertByte);\n        // 读取接收者私钥\n        byte[] privateKeyBytes = new byte[2048];\n        FileInputStream in_privatekey = new FileInputStream(receivePrivateKeyPath);\n        in_privatekey.read(privateKeyBytes);\n        in_privatekey.close();\n        JKey privateKey = new JKey(JKey.SM2_PRV_KEY, privateKeyBytes);\n        p7recCertKey[] recs1 = new p7recCertKey[1];\n        // 设置接收者私钥和接收者证书\n        recs1[0] = new p7recCertKey(privateKey, receiveCert);\n        // 验证P7数字信封 解密原文\n        byte[] src = p7.verifyP7Env(recs1, null);\n        if (src != null && src.length > 0) {\n            System.out.println(\"验签解密成功..............\");\n            System.out.println(\"原文为： \" + new String(src, StandardCharsets.UTF_8));\n        }\n    } catch (Exception e) {\n        e.printStackTrace();\n    }\n}"
    }
]